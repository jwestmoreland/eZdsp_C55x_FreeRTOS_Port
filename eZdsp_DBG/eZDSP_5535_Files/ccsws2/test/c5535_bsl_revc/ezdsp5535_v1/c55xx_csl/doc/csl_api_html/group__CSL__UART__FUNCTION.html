<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>C55XX CSL Version 2.50: UART Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">UART Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__CSL__UART__API.html">UART</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gacff5081720163b3c964defacc15e60b8">UART_init</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartObj</a> *uartObj, Uint32 uartInstId, <a class="el" href="group__CSL__UART__ENUM.html#gadb8f91c9e0a2a604d5a85fb25e0a5e1c">CSL_UartOpmode</a> opmode)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga2c72ae773c3641614cf81c8cba0e8866">UART_setup</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, <a class="el" href="structCSL__UartSetup.html">CSL_UartSetup</a> *uartSetup)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga78eb97f96b5598700eba19531458a3ee">UART_config</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, <a class="el" href="structCSL__UartConfig.html">CSL_UartConfig</a> *uartConfig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga342a469aaff711aebaec48ca0728cf19">UART_setupBaudRate</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, Uint32 clkInput, Uint32 baudRate)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga60e5fe44b9617fe1eee1ba9f94def436">UART_reset</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga557bdcf804b5ce4d973a51342e459c67">UART_resetOff</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gae84e062473d8a86b3c35483185a7ce7a">UART_eventEnable</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, <a class="el" href="group__CSL__UART__ENUM.html#ga12517be01e573d2c8c1ad875e2c2d529">CSL_UartEventType</a> uartEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga1f4c4d95a5e8810714bedf631c195c1d">UART_eventDisable</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, <a class="el" href="group__CSL__UART__ENUM.html#ga12517be01e573d2c8c1ad875e2c2d529">CSL_UartEventType</a> uartEvent)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gad4df8e5f69c691656473c81630b3bc50">UART_read</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, Char *pBuf, Uint16 count, Uint32 timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga3c28d5d2a132b3722794c437018fc91a">UART_write</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, Char *pBuf, Uint16 count, Uint32 timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga070530933345a6403e523869783cec30">UART_fgetc</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, Char *elem, Uint32 timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga36d8e33d38839512893342162d693f83">UART_fputc</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, const Char elem, Uint32 timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga7ccf5299bcca976c211b12deb5bb79ed">UART_fgets</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, Char *pBuf, Uint16 bufSize, Uint32 timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga733d8f3bdfa21866cf091490b1498ed1">UART_fputs</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, const Char *pBuf, Uint32 timeout)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Int16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gad606bc779b910f78730f23589e434fef">UART_getEventId</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga11a06e67017d8fc49b1f371cdf8de5e1">UART_getConfig</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, <a class="el" href="structCSL__UartConfig.html">CSL_UartConfig</a> *config)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga576ad50502353e36e7e5cec5b048574f">UART_setCallback</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart, <a class="el" href="structCSL__UartIsrAddr.html">CSL_UartIsrAddr</a> *isrAddr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga1870e020cef4ea6c19a3407f11676ebf">UART_getDataReadyStatus</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gac0abd3e3b415c26bd42a8c00ba9fe7cd">UART_getXmitHoldRegEmptyStatus</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gacf5f530540f730f42bb972bb1d322949">UART_getRecvorResetStatus</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga41ff11188eaea0f27436d72012e49da7">UART_getXmitorResetState</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static <a class="el" href="group__CSL__UART__ENUM.html#ga482046cb8c1140e3d8cd5f778f698591">CSL_UartXferMode</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga7a7de8a5a9d94678c8eb024e072ee2eb">UART_getModeOfTransfer</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gae6c660c2eb268feba198a9772ef5be12">UART_setToIntMode</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga8a905d6ea873b831a2512e80092bc256">UART_setToPollMode</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#ga9e4b26ccad5e35ad59eea33e1e150b07">UART_enableFreeRun</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__UART__FUNCTION.html#gad15566077a22f2da2f4dbda9dfb1a495">UART_disableFreeRun</a> (<a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a> hUart)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ga78eb97f96b5598700eba19531458a3ee"></a><!-- doxytag: member="csl_uart.h::UART_config" ref="ga78eb97f96b5598700eba19531458a3ee" args="(CSL_UartHandle hUart, CSL_UartConfig *uartConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_config </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UartConfig.html">CSL_UartConfig</a> *&#160;</td>
          <td class="paramname"><em>uartConfig</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_config</b> </p>
<p><b>Description</b> <br/>
 This is a low level API than UART_setup API. It's used to configure registers directly.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 		hUart  Handle to the UART.
		pConfig     Pointer to the CSL_UartConfig structure.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_config call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid pointer to UART Config strucutre. <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 Confgiure the registers.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status              status;
 	    CSL_UartObj                uartObj;
        Uint32                      uartInstId;
        CSL_UartConfig 		 Config;

        Config.DLL  =
        Config.DLH =
        Config.LCR  =
        Config.FCR =
        Config.MCR =
        uartInstId = 0;

        status = UART_init(&amp;uartObj,uartInstId);
        status =  UART_config(CSL_UartHandle hUart,&amp;Config);
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_config</b> </p>
<p><b>Description</b> <br/>
 This is a low level API which is used to confgiure registers DLL,DLH,FCR,MCR,LCR. <b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 		hUart  Handle to the UART.
		pConfig     Pointer to the CSL_UartConfig structure.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_config call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid pointer to UART Config strucutre. <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 Registers are configured.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status              status;
 	    CSL_UartObj                uartObj;
        CSL_UartHandle             hUart;
        Uint32                  uartInstId;
        CSL_UartConfig 		    Config;
        CSL_UartSetup              uartSetup;            
        uartInstId  = 0;
 
        Config.FCR = CSL_UART_FIFO_DMA1_DISABLE_TRIG01;
        Config.DLL = 0x001b;
        Config.DLH = 0x0006;
        Config.LCR = 0x0003 
        Config.MCR = 0x0000;

        status = UART_init(&amp;uartObj,uartInstId);
        hUart = (CSL_UartHandle)&amp;uartObj);
        status = UART_reset(hUart);
        status = UART_config(hUart,&amp;Config);
        status = UART_resetOff(hUart);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartConfig.html#a1937b19937ac4ac7f27c2965f0657fe9">CSL_UartConfig::DLH</a>, <a class="el" href="structCSL__UartConfig.html#a11bc5ee6fca1df958a003f061226fe78">CSL_UartConfig::DLL</a>, <a class="el" href="structCSL__UartConfig.html#a75c041e19e691b20b309c647edabf196">CSL_UartConfig::FCR</a>, <a class="el" href="structCSL__UartConfig.html#a569456837629509b1a14d541fba98927">CSL_UartConfig::LCR</a>, <a class="el" href="structCSL__UartConfig.html#a774d5e06cc3fa616b89a54556212c779">CSL_UartConfig::MCR</a>, <a class="el" href="structCSL__UartObj.html#a58c0ca2c9fa0c69f929bbde55493cdff">CSL_UartObj::trigLevel</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="gad15566077a22f2da2f4dbda9dfb1a495"></a><!-- doxytag: member="csl_uartAux.h::UART_disableFreeRun" ref="gad15566077a22f2da2f4dbda9dfb1a495" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status UART_disableFreeRun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_disableFreeRun</b> </p>
<p><b>Description</b> <br/>
 This API is used to stop free running mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_ESYS_BADHANDLE - Invalid handle.</li>
</ul>
<ul>
<li>CSL_SOK - Stop Free running mode.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         CSL_UartSetup                 uartSetup;
         uartInstId = 0;

         uartSetup.afeEnable = CSL_UART_NO_AFE;
         uartSetup.baud = 2400;
         uartSetup.clkInput = 60000000;
         uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
         uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
         uartSetup.parity =  CSL_UART_DISABLE_PARITY;
         uartSetup.rtsEnable = CSL_UART_NO_RTS;
         uartSetup.stopBits = 0;
         uartSetup.wordLength = CSL_UART_WORD8;

         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         status = UART_setup(hUart,&amp;setup);
         status = UUART_disableFreeRun(hUart);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga9e4b26ccad5e35ad59eea33e1e150b07"></a><!-- doxytag: member="csl_uartAux.h::UART_enableFreeRun" ref="ga9e4b26ccad5e35ad59eea33e1e150b07" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status UART_enableFreeRun </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_enableFreeRun</b> </p>
<p><b>Description</b> <br/>
 This API is used to start free running mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_ESYS_BADHANDLE - Invalid handle.</li>
</ul>
<ul>
<li>CSL_SOK - Free running mode is enabled.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         CSL_UartConfig                config;
         uartInstId = 0;
         config.FCR = CSL_UART_FIFO_DMA1_DISABLE_TRIG01;
         config.DLL = 0x001b;
         config.DLH = 0x0006;
         config.LCR = 0x0003
         config.MCR = 0x0000;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         status = UART_config(hUart,&amp;config);
         status = UART_resetOff(hUart);
         status = UUART_enableFreeRun(hUart);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga1f4c4d95a5e8810714bedf631c195c1d"></a><!-- doxytag: member="csl_uart.h::UART_eventDisable" ref="ga1f4c4d95a5e8810714bedf631c195c1d" args="(CSL_UartHandle hUart, CSL_UartEventType uartEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_eventDisable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__UART__ENUM.html#ga12517be01e573d2c8c1ad875e2c2d529">CSL_UartEventType</a>&#160;</td>
          <td class="paramname"><em>uartEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_eventDisable</b> </p>
<p><b>Description</b> <br/>
 This API is used to enable events like Receiver data availabe, Transmitter holding register empty</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
	    isrMask Particular events can be disabled by setting correspoding
       	bits in the variable
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_eventDisable call is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 The correspoding events are disabled.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     CSL_Status              status;
 	     CSL_UartObj                uartObj;
         Uint32                  uartInstId;
         CSL_UartSetup 		     uartSetup;
         Uint16 isrMask = 0x01;
         uartInstId = 0;

         uartSetup.afeEnable = CSL_UART_NO_AFE;
         uartSetup.baud = 2400;
         uartSetup.clkInput = 60000000;
         uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
         uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
         uartSetup.parity =  CSL_UART_DISABLE_PARITY;
         uartSetup.rtsEnable = CSL_UART_NO_RTS;
         uartSetup.stopBits = 0;
         uartSetup.wordLength = CSL_UART_WORD8;

         status = UART_init(&amp;uartObj,uartInstId);
         status = UART_eventDisable(&amp;uartObj,CSL_RTC_RECVOR_REG_DATA_INTERRUPT);
         status = CSL_UartSetup( hUart,&amp;uartSetup);
         status = UART_eventEnable(hUart,CSL_RTC_XMITOR_REG_EMPTYINTERRUPT);

     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_eventDisable</b> </p>
<p><b>Description</b> <br/>
 This API is used to enable events like Receiver data availabe, Transmitter holding register empty</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
	    isrMask Particular events can be disabled by setting correspoding 
       	bits in the variable
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_eventDisable call is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 The correspoding events are disabled.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     CSL_Status              status;
 	     CSL_UartObj                uartObj;
         Uint32                  uartInstId;
         CSL_UartSetup 		     uartSetup;
         Uint16 isrMask = 0x01;
         uartInstId = 0;

         uartSetup.afeEnable = CSL_UART_NO_AFE;
         uartSetup.baud = 2400;
         uartSetup.clkInput = 60000000;
         uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
         uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
         uartSetup.parity =  CSL_UART_DISABLE_PARITY;
         uartSetup.rtsEnable = CSL_UART_NO_RTS;
         uartSetup.stopBits = 0;
         uartSetup.wordLength = CSL_UART_WORD8;

         status = UART_init(&amp;uartObj,uartInstId);
         status = UART_eventDisable(&amp;uartObj,CSL_UART_RECVOR_REG_DATA_INTERRUPT);		          
         status = UART_setup( hUart,&amp;uartSetup);
         status = UART_eventEnable(hUart,CSL_UART_XMITOR_REG_EMPTYINTERRUPT);
	     
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__UART__ENUM.html#gga12517be01e573d2c8c1ad875e2c2d529a4a9e911eba369f01242d801aea26ac8f">CSL_UART_RECVOR_LINE_STATUS_INTERRUPT</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga12517be01e573d2c8c1ad875e2c2d529af7e4bc0704b1f4a7009caacc4eae19e2">CSL_UART_RECVOR_REG_DATA_INTERRUPT</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga12517be01e573d2c8c1ad875e2c2d529a7d44452881ede3f7e4272e063ba16788">CSL_UART_XMITOR_REG_EMPTY_INTERRUPT</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="gae84e062473d8a86b3c35483185a7ce7a"></a><!-- doxytag: member="csl_uart.h::UART_eventEnable" ref="gae84e062473d8a86b3c35483185a7ce7a" args="(CSL_UartHandle hUart, CSL_UartEventType uartEvent)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_eventEnable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__UART__ENUM.html#ga12517be01e573d2c8c1ad875e2c2d529">CSL_UartEventType</a>&#160;</td>
          <td class="paramname"><em>uartEvent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_eventEnable</b> </p>
<p><b>Description</b> <br/>
 This API is used to enable events like Receiver data availabe, Transmitter holding register empty</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 		hUart  Handle to the UART.
	 	isrMask Interested particular events can be enabled by setting the
        correspoding bits in the variable
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_eventEnable call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 The corresponding events are enabled.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	    CSL_Status              status;
 	    CSL_UartObj                uartObj;
       	CSL_UartSetup 		        uartSetup;
     	Uint16 isrMask = 0x01;
     	Uint32 uartInstId = 0x0;
        uartSetup.afeEnable = CSL_UART_NO_AFE;
        uartSetup.baud = 2400;
        uartSetup.clkInput = 60000000;
        uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
        uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
        uartSetup.parity =  CSL_UART_DISABLE_PARITY;
        uartSetup.rtsEnable = CSL_UART_NO_RTS;
        uartSetup.stopBits = 0;
        uartSetup.wordLength = CSL_UART_WORD8;
    	status = UART_init(&amp;uartObj,uartInstId);
        status = UART_Setup( &amp;uartObj,&amp;uartSetup);
        status = UART_eventEnable(&amp;uartObj,CSL_RTC_RECVOR_REG_DATA_INTERRUPT)
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_eventEnable</b> </p>
<p><b>Description</b> <br/>
 This API is used to enable events like Receiver data availabe, Transmitter holding register empty</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 		hUart  Handle to the UART.
	 	isrMask Interested particular events can be enabled by setting the 
        correspoding bits in the variable
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_eventEnable call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 The corresponding events are enabled.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	    CSL_Status              status;
 	    CSL_UartObj                uartObj;
       	CSL_UartSetup 		        uartSetup;
     	Uint16 isrMask = 0x01;
     	Uint32 uartInstId = 0x0;
        uartSetup.afeEnable = CSL_UART_NO_AFE;
        uartSetup.baud = 2400;
        uartSetup.clkInput = 60000000;
        uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
        uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
        uartSetup.parity =  CSL_UART_DISABLE_PARITY;
        uartSetup.rtsEnable = CSL_UART_NO_RTS;
        uartSetup.stopBits = 0;
        uartSetup.wordLength = CSL_UART_WORD8;
    	status = UART_init(&amp;uartObj,uartInstId);
        status = UART_setup( &amp;uartObj,&amp;uartSetup);
        status = UART_eventEnable(&amp;uartObj,CSL_UART_RECVOR_REG_DATA_INTERRUPT)       
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__UART__ENUM.html#gga12517be01e573d2c8c1ad875e2c2d529a4a9e911eba369f01242d801aea26ac8f">CSL_UART_RECVOR_LINE_STATUS_INTERRUPT</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga12517be01e573d2c8c1ad875e2c2d529af7e4bc0704b1f4a7009caacc4eae19e2">CSL_UART_RECVOR_REG_DATA_INTERRUPT</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga12517be01e573d2c8c1ad875e2c2d529a7d44452881ede3f7e4272e063ba16788">CSL_UART_XMITOR_REG_EMPTY_INTERRUPT</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga070530933345a6403e523869783cec30"></a><!-- doxytag: member="csl_uart.h::UART_fgetc" ref="ga070530933345a6403e523869783cec30" args="(CSL_UartHandle hUart, Char *elem, Uint32 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_fgetc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Char *&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_fgetc</b> </p>
<p><b>Description</b> <br/>
 UART_fgetc reads a single character from the RBR into elem.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 		hUart  Handle to the UART.
        elem   A size one buffer.
        timeout Timeout value
                0 - wait indefinitely for DR bit to get set.
                x - wait x value for DR bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fgetc call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid address of input buffer </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to DR bit not set. <b> Pre Condition </b> <br/>
 UART_init and <a class="el" href="structCSL__UartSetup.html" title="UART Setup structure.">CSL_UartSetup</a> should be called successfully. <b> Post Condition </b> <br/>
 elem contains a single character.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <br/>
 elem is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
         	Uint32                      uartInstId;
            CSL_UartSetup 		 uartSetup;
            CSL_UartHandle hUart;
            Char  buf[1];
            uartInstId = 0;

            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status =  CSL_UartSetup( hUart,&amp;uartSetup);
            status = UART_fgetc(hUart,buf,200)
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_fgetc</b> </p>
<p><b>Description</b> <br/>
 UART_fgetc reads a single character from the RBR into elem.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 		hUart  Handle to the UART.
        elem   A size one buffer.
        timeout Timeout value 
                0 - wait indefinitely for DR bit to get set.
                x - wait x value for DR bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fgetc call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid address of input buffer </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to DR bit not set. <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 elem will have a single character.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <br/>
 elem is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
         	Uint32                      uartInstId;
            CSL_UartSetup 		 uartSetup;
            CSL_UartHandle hUart;
            Char  buf[1];
            uartInstId = 0;

            uartSetup.afeEnable = CSL_UART_NO_AFE;
            uartSetup.baud = 2400;
            uartSetup.clkInput = 60000000;
            uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
            uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
            uartSetup.parity =  CSL_UART_DISABLE_PARITY;
            uartSetup.rtsEnable = CSL_UART_NO_RTS;
            uartSetup.stopBits = 0;
            uartSetup.wordLength = CSL_UART_WORD8;
 
            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status =  UART_setup( hUart,&amp;uartSetup);
            status = UART_fgetc(hUart,buf,200)
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="csl__error_8h.html#a5bf9c47547e0e302c43e3519537ff167">CSL_EUART_TIMEOUT</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#ga1870e020cef4ea6c19a3407f11676ebf">UART_getDataReadyStatus()</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga7ccf5299bcca976c211b12deb5bb79ed"></a><!-- doxytag: member="csl_uart.h::UART_fgets" ref="ga7ccf5299bcca976c211b12deb5bb79ed" args="(CSL_UartHandle hUart, Char *pBuf, Uint16 bufSize, Uint32 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_fgets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Char *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>bufSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_fgets</b> </p>
<p><b>Description</b> <br/>
 UART_fgets reads in at most one less than bufSize characters from RBR and stores them into the buffer pointed to by pBuf.Reading stops after a newline. If a newline is read, it is stored into the buffer. A "\0" is stored after the last character in the buffer. <b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
	        hUart  Handle to the UART.
       	 	pBuf   Output buffer
	        bufSize  Size of output buffer
            timeout Timeout value
                    0 - wait indefinitely for DR bit to get set.
                    x - wait x value for DR bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fgets call is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle. </li>
<li>CSL_ESYS_INVPARAMS- Invalid output buffer </li>
<li>CSL_EUART_INVALID_LENGTH- Invalid string length. </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to DR bit not set. <b> Pre Condition </b> <br/>
 UART_init and <a class="el" href="structCSL__UartSetup.html" title="UART Setup structure.">CSL_UartSetup</a> should be called successfully. <b> Post Condition </b> <br/>
 Input buffer will contain a string.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <br/>
 pBuf is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	        CSL_Status              status;
 	        CSL_UartObj                uartObj;
            Uint32                      uartInstId;
            CSL_UartSetup 		 uartSetup;
            CSL_UartHandle hUart;
            Char  buf[12];
            Uint16 N = 12;
            uartInstId = 0;

            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status =  CSL_UartSetup( hUart,&amp;uartSetup);
            status = UART_fgets(hUart,buf,N,100) ;

     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_fgets</b> </p>
<p><b>Description</b> <br/>
 UART_fgets reads in at most one less than bufSize characters from RBR and stores them into the buffer pointed to by pBuf.Reading stops after a newline. If a newline is read, it is stored into the buffer. A '\0' is stored after the last character in the buffer. <b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
	        hUart  Handle to the UART.
       	 	pBuf   Output buffer
	        bufSize  Size of output buffer              
            timeout Timeout value 
                    0 - wait indefinitely for DR bit to get set.
                    x - wait x value for DR bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fgets call is successful </li>
<li>CSL_ESYS_BADHANDLE - Invalid handle. </li>
<li>CSL_ESYS_INVPARAMS- Invalid output buffer </li>
<li>CSL_EUART_INVALID_LENGTH- Invalid string length. </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to DR bit not set. <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 Input buffer will have a string.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <br/>
 pBuf is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	        CSL_Status              status;
 	        CSL_UartObj                uartObj;
            Uint32                  uartInstId;
            CSL_UartSetup 		        uartSetup;
            CSL_UartHandle hUart;
            Char  buf[12];
            Uint16 N = 12;
            uartInstId = 0;

            uartSetup.afeEnable = CSL_UART_NO_AFE;
            uartSetup.baud = 2400;
            uartSetup.clkInput = 60000000;
            uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
            uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
            uartSetup.parity =  CSL_UART_DISABLE_PARITY;
            uartSetup.rtsEnable = CSL_UART_NO_RTS;
            uartSetup.stopBits = 0;
            uartSetup.wordLength = CSL_UART_WORD8;
 
            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status =  CSL_UartSetup( hUart,&amp;uartSetup);
            status = UART_fgets(hUart,buf,N,100) ;
            
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="csl__error_8h.html#a7ffbb1d95c8de5e7168f29f6da39ad33">CSL_EUART_INVALID_BUFSIZE</a>, <a class="el" href="csl__error_8h.html#a5bf9c47547e0e302c43e3519537ff167">CSL_EUART_TIMEOUT</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#ga1870e020cef4ea6c19a3407f11676ebf">UART_getDataReadyStatus()</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga36d8e33d38839512893342162d693f83"></a><!-- doxytag: member="csl_uart.h::UART_fputc" ref="ga36d8e33d38839512893342162d693f83" args="(CSL_UartHandle hUart, const Char elem, Uint32 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_fputc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char&#160;</td>
          <td class="paramname"><em>elem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_fputc</b> </p>
<p><b>Description</b> <br/>
 UART_fputc writes a single character to THR(Transmitter Holding Register).</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
	    elem   Character to transmit
        timeout Timeout value
                0 - wait indefinitely for THRE bit to get set.
                x - wait x value for THRE bit to get set.
     </pre></div><p> <b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fputc call is successful </li>
<li>CSL_ESYS_BADHANDLE - Handle is invalid </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to THRE bit not set. <b> Pre Condition </b> <br/>
 UART_init and <a class="el" href="structCSL__UartSetup.html" title="UART Setup structure.">CSL_UartSetup</a> should be called successfully. <b> Post Condition </b> <br/>
 A character got transmitted.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            Uint32                  uartInstId;
            CSL_UartSetup 		        uartSetup;
            CSL_UartHandle hUart;
            Char  buf[1];
            uartInstId = 0;

            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status = CSL_UartSetup( hUart,&amp;uartSetup);
            status = UART_fputc(hUart,buf[0],200)

     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_fputc</b> </p>
<p><b>Description</b> <br/>
 UART_fputc writes a single character to THR(Transmitter Holding Register).</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
	    elem   Character to transmit  
        timeout Timeout value 
                0 - wait indefinitely for THRE bit to get set.
                x - wait x value for THRE bit to get set.
     </pre></div><p> <b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fputc call is successful </li>
<li>CSL_ESYS_BADHANDLE - Handle is invalid </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to THRE bit not set. <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 A character will get transmitted.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            Uint32                  uartInstId;
            CSL_UartSetup 		        uartSetup;
            CSL_UartHandle hUart;
            Char  buf[1];
            uartInstId = 0;
 
            uartSetup.afeEnable = CSL_UART_NO_AFE;
            uartSetup.baud = 2400;
            uartSetup.clkInput = 60000000;
            uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
            uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
            uartSetup.parity =  CSL_UART_DISABLE_PARITY;
            uartSetup.rtsEnable = CSL_UART_NO_RTS;
            uartSetup.stopBits = 0;
            uartSetup.wordLength = CSL_UART_WORD8;

            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status = UART_setup( hUart,&amp;uartSetup);
            status = UART_fputc(hUart,buf[0],200)
            
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="csl__error_8h.html#a5bf9c47547e0e302c43e3519537ff167">CSL_EUART_TIMEOUT</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#gac0abd3e3b415c26bd42a8c00ba9fe7cd">UART_getXmitHoldRegEmptyStatus()</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga733d8f3bdfa21866cf091490b1498ed1"></a><!-- doxytag: member="csl_uart.h::UART_fputs" ref="ga733d8f3bdfa21866cf091490b1498ed1" args="(CSL_UartHandle hUart, const Char *pBuf, Uint32 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_fputs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Char *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_fputs</b> </p>
<p><b>Description</b> <br/>
 UART_fputs writes the string pointed by pBuf to THR, without its trailing "\0".</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">

        hUart  Handle to the UART.
        pBuf   Input buffer
        timeout Timeout value
                0 - wait indefinitely for THRE bit to get set.
                x - wait x value for THRE bit to get set.

      </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fputs call is successful </li>
<li>CSL_ESYS_BADHANDLE - UART_fputs call is successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid input buffer </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to THRE bit not set. <b> Pre Condition </b> <br/>
 UART_init and <a class="el" href="structCSL__UartSetup.html" title="UART Setup structure.">CSL_UartSetup</a> should be called successfully. <b> Post Condition </b> <br/>
 A string will get transmitted.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            Uint32                  uartInstId;
            CSL_UartSetup 		        uartSetup;
            CSL_UartHandle hUart;
            Char  buf[12] ="Test";
            uartInstId = 0;
            status =  UART_init(&amp;uartObj,uartInstId);
            hUart  = (CSL_UartHandle)&amp;uartObj;
            status =  UART_Setup( hUart,&amp;uartSetup);
            status =  UART_fputs(hUart,buf);
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_fputs</b> </p>
<p><b>Description</b> <br/>
 UART_fputs writes the string pointed by pBuf to THR, without its trailing '\0'.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 
        hUart  Handle to the UART.
        pBuf   Input buffer      
        timeout Timeout value 
                0 - wait indefinitely for THRE bit to get set.
                x - wait x value for THRE bit to get set.
        
      </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_fputs call is successful </li>
<li>CSL_ESYS_BADHANDLE - UART_fputs call is successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid input buffer </li>
<li>CSL_EUART_TIMEOUT - had a timeout due to THRE bit not set. <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 A string will get transmitted.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            Uint32                  uartInstId;
            CSL_UartSetup 		        uartSetup;
            CSL_UartHandle             hUart;
            Char  buf[12] ="Test";
            uartInstId = 0;
 
            uartSetup.afeEnable = CSL_UART_NO_AFE;
            uartSetup.baud = 2400;
            uartSetup.clkInput = 60000000;
            uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
            uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
            uartSetup.parity =  CSL_UART_DISABLE_PARITY;
            uartSetup.rtsEnable = CSL_UART_NO_RTS;
            uartSetup.stopBits = 0;
            uartSetup.wordLength = CSL_UART_WORD8;
 
            status =  UART_init(&amp;uartObj,uartInstId);
            hUart  = (CSL_UartHandle)&amp;uartObj;
            status =  UART_setup( hUart,&amp;uartSetup);
            status =  UART_fputs(hUart,buf);            
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="csl__error_8h.html#a5bf9c47547e0e302c43e3519537ff167">CSL_EUART_TIMEOUT</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#gac0abd3e3b415c26bd42a8c00ba9fe7cd">UART_getXmitHoldRegEmptyStatus()</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga11a06e67017d8fc49b1f371cdf8de5e1"></a><!-- doxytag: member="csl_uart.h::UART_getConfig" ref="ga11a06e67017d8fc49b1f371cdf8de5e1" args="(CSL_UartHandle hUart, CSL_UartConfig *config)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_getConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UartConfig.html">CSL_UartConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_getEventId</b> </p>
<p><b>Description</b> <br/>
 UART_getEventId returns the event id in the Handle.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
         None
       </pre></div><p><b> Return Value </b> Uint16 </p>
<ul>
<li>IRQ_EVT_UART -UART_getEventId call is successful. <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 None</li>
</ul>
<p><b>Modifies</b> <br/>
 None <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
             CSL_Status              status;
             CSL_UartObj                uartObj;
             Uint32                      uartInstId;
             Uint16                      uartEvtId;
             uartInstId = 0;
             status =  UART_init(&amp;uartObj,uartInstId);
             uartEvtId =  UART_getEventId();
      </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_getConfig</b> </p>
<p><b>Description</b> <br/>
 UART_getEventId returns the event id in the Handle.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
        None
      </pre></div><p><b> Return Value </b> Uint16 </p>
<ul>
<li>IRQ_EVT_UART -UART_getEventId call is successful. <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 None</li>
</ul>
<p><b>Modifies</b> <br/>
 None <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            Uint32                  uartInstId;
            Uint16                  uartEvtId;
            CSL_UartSetup              uartSetup;
            CSL_UartConfig             getconfig;
            uartInstId = 0;
 
            uartSetup.afeEnable = CSL_UART_NO_AFE;
            uartSetup.baud = 2400;
            uartSetup.clkInput = 60000000;
            uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
            uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
            uartSetup.parity =  CSL_UART_DISABLE_PARITY;
            uartSetup.rtsEnable = CSL_UART_NO_RTS;
            uartSetup.stopBits = 0;
            uartSetup.wordLength = CSL_UART_WORD8;
 
            status =  UART_init(&amp;uartObj,uartInstId);
            status =  UART_Setup(hUart,&amp;uartSetup);                         
            status =  UART_getConfig(hUart,&amp;getconfig);                         
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartConfig.html#a1937b19937ac4ac7f27c2965f0657fe9">CSL_UartConfig::DLH</a>, <a class="el" href="structCSL__UartConfig.html#a11bc5ee6fca1df958a003f061226fe78">CSL_UartConfig::DLL</a>, <a class="el" href="structCSL__UartConfig.html#a75c041e19e691b20b309c647edabf196">CSL_UartConfig::FCR</a>, <a class="el" href="structCSL__UartConfig.html#a569456837629509b1a14d541fba98927">CSL_UartConfig::LCR</a>, <a class="el" href="structCSL__UartConfig.html#a774d5e06cc3fa616b89a54556212c779">CSL_UartConfig::MCR</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga1870e020cef4ea6c19a3407f11676ebf"></a><!-- doxytag: member="csl_uartAux.h::UART_getDataReadyStatus" ref="ga1870e020cef4ea6c19a3407f11676ebf" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Bool UART_getDataReadyStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_getDataReadyStatus</b> </p>
<p><b>Description</b> <br/>
 This API is used to get the status of DR bit in LSR reg</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> Bool </p>
<ul>
<li>TRUE - DR bit is set</li>
</ul>
<ul>
<li>FALSE - DR bit is not set.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         Bool                    	bStatus;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         uartInstId = 0;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         bStatus = UART_getDataReadyStatus(hUart);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__UART__FUNCTION.html#ga070530933345a6403e523869783cec30">UART_fgetc()</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#ga7ccf5299bcca976c211b12deb5bb79ed">UART_fgets()</a>, and <a class="el" href="group__CSL__UART__FUNCTION.html#gad4df8e5f69c691656473c81630b3bc50">UART_read()</a>.</p>

</div>
</div>
<a class="anchor" id="gad606bc779b910f78730f23589e434fef"></a><!-- doxytag: member="csl_uart.h::UART_getEventId" ref="gad606bc779b910f78730f23589e434fef" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Int16 UART_getEventId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_getEventId</b> </p>
<p><b>Description</b> <br/>
 UART_getEventId returns the event id.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
        None
      </pre></div><p><b> Return Value </b> Int16 </p>
<ul>
<li>Returns Eventid - call is successful. </li>
<li>Returns CSL_ESYS_BADHANDLE - Handle is NULL. <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 None</li>
</ul>
<p><b>Modifies</b> <br/>
 None <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            CSL_UartHandle             hUart;
            Uint16                  uartEvtId;
            Uint32 uartInstId = 0;
            status =  UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)(&amp;uartObj);
            uartEvtId =  UART_getEventId(hUart);
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_getEventId</b> </p>
<p><b>Description</b> <br/>
 UART_getEventId returns the event id in the Handle.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
        None
      </pre></div><p><b> Return Value </b> Uint16 </p>
<ul>
<li>IRQ_EVT_UART -UART_getEventId call is successful. <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 None</li>
</ul>
<p><b>Modifies</b> <br/>
 None <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            CSL_UartHandle             hUart;
            Uint16                  uartEvtId;
            Uint32 uartInstId = 0;
            status =  UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)(&amp;uartObj);
            uartEvtId =  UART_getEventId(hUart);                         
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga7a7de8a5a9d94678c8eb024e072ee2eb"></a><!-- doxytag: member="csl_uartAux.h::UART_getModeOfTransfer" ref="ga7a7de8a5a9d94678c8eb024e072ee2eb" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="group__CSL__UART__ENUM.html#ga482046cb8c1140e3d8cd5f778f698591">CSL_UartXferMode</a> UART_getModeOfTransfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_getModeOfTransfer</b> </p>
<p><b>Description</b> <br/>
 This API is used to get Xfer mode of UART in ,Fifo mode or non fifo mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> CSL_UartXferMode </p>
<ul>
<li>CSL_UART_FIFO_MODE - UART in fifo mode.</li>
</ul>
<ul>
<li>CSL_UART_NON_FIFO_MODE - UART in non fifo mode.</li>
</ul>
<ul>
<li>CSL_UART_MODE_UNDEFINED - UART Xfer mode is undefined.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         CSL_UartXferMode       uartXferMode;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         CSL_UartSetup                 uartSetup;
         uartSetup.....

         uartInstId = 0;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         status = UART_setup(hUart,&amp;uartSetup);
         uartXferMode = UART_getModeOfTransfer(hUart);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__UART__ENUM.html#gga482046cb8c1140e3d8cd5f778f698591a789b2d692d2de80e25b65362c4d4ccb4">CSL_UART_FIFO_MODE</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga482046cb8c1140e3d8cd5f778f698591a0710656c395d983c51d2998049565231">CSL_UART_MODE_UNDEFINED</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga482046cb8c1140e3d8cd5f778f698591a652890174b2e0c5e2c85efbe6df01443">CSL_UART_NON_FIFO_MODE</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__UART__FUNCTION.html#ga3c28d5d2a132b3722794c437018fc91a">UART_write()</a>.</p>

</div>
</div>
<a class="anchor" id="gacf5f530540f730f42bb972bb1d322949"></a><!-- doxytag: member="csl_uartAux.h::UART_getRecvorResetStatus" ref="gacf5f530540f730f42bb972bb1d322949" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status UART_getRecvorResetStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_getRecvorResetStatus</b> </p>
<p><b>Description</b> <br/>
 This API is used to get the Receiver reset status</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> Bool </p>
<ul>
<li>TRUE - Receiver in reset state.</li>
</ul>
<ul>
<li>FALSE - Receiver is enabled.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         Bool                    	bStatus;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         uartInstId = 0;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         bStatus = UART_getRecvorResetStatus(hUart);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="gac0abd3e3b415c26bd42a8c00ba9fe7cd"></a><!-- doxytag: member="csl_uartAux.h::UART_getXmitHoldRegEmptyStatus" ref="gac0abd3e3b415c26bd42a8c00ba9fe7cd" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Bool UART_getXmitHoldRegEmptyStatus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_getXmitHoldRegEmptyStatus</b> </p>
<p><b>Description</b> <br/>
 This API is used to get the status of THRE bit in LSR reg</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> Bool </p>
<ul>
<li>TRUE - THRE bit is set</li>
</ul>
<ul>
<li>FALSE - THRE bit is not set.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         Bool                    	bStatus;
         CSL_UartObj         		uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         uartInstId = 0;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         bStatus = UART_getXmitHoldRegEmptyStatus(hUart);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__UART__FUNCTION.html#ga36d8e33d38839512893342162d693f83">UART_fputc()</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#ga733d8f3bdfa21866cf091490b1498ed1">UART_fputs()</a>, and <a class="el" href="group__CSL__UART__FUNCTION.html#ga3c28d5d2a132b3722794c437018fc91a">UART_write()</a>.</p>

</div>
</div>
<a class="anchor" id="ga41ff11188eaea0f27436d72012e49da7"></a><!-- doxytag: member="csl_uartAux.h::UART_getXmitorResetState" ref="ga41ff11188eaea0f27436d72012e49da7" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status UART_getXmitorResetState </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_getXmitorResetState</b> </p>
<p><b>Description</b> <br/>
 This API is used to get the Receiver reset status</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> Bool </p>
<ul>
<li>TRUE - Transmittor in reset state.</li>
</ul>
<ul>
<li>FALSE - Transmittor is enabled.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         Bool                    	bStatus;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         uartInstId = 0;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         bStatus = UART_getXmitorResetState(hUart);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="gacff5081720163b3c964defacc15e60b8"></a><!-- doxytag: member="csl_uart.h::UART_init" ref="gacff5081720163b3c964defacc15e60b8" args="(CSL_UartObj *uartObj, Uint32 uartInstId, CSL_UartOpmode opmode)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartObj</a> *&#160;</td>
          <td class="paramname"><em>uartObj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>uartInstId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__UART__ENUM.html#gadb8f91c9e0a2a604d5a85fb25e0a5e1c">CSL_UartOpmode</a>&#160;</td>
          <td class="paramname"><em>opmode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_init</b> </p>
<p><b>Description</b> <br/>
 This is the initialization function for the uart CSL. The function must be called before calling any other API from this CSL. This will initialize the uart object. <b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		uartInstId  Instance number of the uart
		uartObj     Pointer to the uart object
        opmode      Operation mode of uart
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Init call is successful </li>
<li>CSL_ESYS_INVPARAMS- Invalid parameter </li>
<li>CSL_UART_INVALID_INST_ID- Invalid instance id <b> Pre Condition </b> <br/>
 None <b> Post Condition </b> <br/>
 PLL object structure is populated</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status              status;
		CSL_UartObj                uartObj;
		Uint32                  uartInstId;
        CSL_UartOpmode opmode = UART_POLLED;
		uartInstId = CSL_UART_INST_0;
		status = UART_init(&amp;uartObj,uartInstId);
     </pre></div><p> ============================================================================ </p>

<p><p>Enable Master clock</p>
<p>Enable uart peripheral clock gating</p>
<p>Resetting UART module </p>
</p>

<p>References <a class="el" href="csl__error_8h.html#a1e445223ca4a22803e2753a46ae5600e">CSL_EUART_INVALID_INST_ID</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga8be3cb10150bf570266663d9c32717b6af9863cf83fc90986b3f13080a82b8403">CSL_UART_INST_0</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga8be3cb10150bf570266663d9c32717b6ac4d4df21fadcf374f791b0fe61c60198">CSL_UART_INST_INVALID</a>, <a class="el" href="structCSL__UartObj.html#a70b85a28b044cc66e97debed533840fe">CSL_UartObj::insId</a>, <a class="el" href="structCSL__UartObj.html#a104ca1045f2a994afa51e5d126c3081e">CSL_UartObj::opmode</a>, <a class="el" href="structCSL__UartObj.html#a7f35db1f95097e381f7b5f8f84037b0c">CSL_UartObj::sysAddr</a>, <a class="el" href="group__CSL__UART__ENUM.html#ggadb8f91c9e0a2a604d5a85fb25e0a5e1ca2ad9be0e1878c7e8071ea0c19698204a">UART_OPMODE_OTHER</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="gad4df8e5f69c691656473c81630b3bc50"></a><!-- doxytag: member="csl_uart.h::UART_read" ref="gad4df8e5f69c691656473c81630b3bc50" args="(CSL_UartHandle hUart, Char *pBuf, Uint16 count, Uint32 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Char *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_read</b> </p>
<p><b>Description</b> <br/>
 UART_read attempts to read up to count characters from <a class="el" href="group__CSL__UART__SYMBOL.html#gaa6f7e7a9f4551d6151f9d45362118a50">RBR(Recieve Buffer Register)</a> into the buffer starting at pBuf</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
	   	pBuf   Output buffer
      	count  No of characters to read.
        timeout Timeout value
                0 - wait indefinitely for DR bit to get set.
                x - wait x value for DR bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_read call is successful. </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid address of the buffer. </li>
<li>CSL_EUART_TIMEOUT - Read had a timeout due to DR bit not set. <b> Pre Condition </b> <br/>
 UART_init and <a class="el" href="structCSL__UartSetup.html" title="UART Setup structure.">CSL_UartSetup</a> should be called successfully. <b> Post Condition </b> <br/>
 pBuf contains count number of characters.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <br/>
 bBuf is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     CSL_Status              status;
 	     CSL_UartObj                uartObj;
         Uint32                  uartInstId;
         CSL_UartSetup 		    uartSetup;
         CSL_UartHandle hUart;
         Char  buf[12];
         Uint16 N = 12;
         uartInstId = 0;

         status = UART_init(&amp;uartObj,uartInstId);
         hUart = (CSL_UartHandle)&amp;uartObj;
         status = CSL_UartSetup( hUart,&amp;uartSetup);
         status = UART_read(hUart,buf,N,1000) ;

     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_read</b> </p>
<p><b>Description</b> <br/>
 UART_read attempts to read up to count characters from <a class="el" href="group__CSL__UART__SYMBOL.html#gaa6f7e7a9f4551d6151f9d45362118a50">RBR(Recieve Buffer Register)</a> into the buffer starting at pBuf in polled mode. In interrupt mode,only charater it will read . <b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
	   	pBuf   Output buffer	
      	count  No of characters to read.
        timeout Timeout value
                0 - wait indefinitely for DR bit to get set.
                x - wait x value for DR bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_read call is successful. </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid address of the buffer. </li>
<li>CSL_EUART_TIMEOUT - Read had a timeout due to DR bit not set. <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 pBuf contains count number of characters.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <br/>
 bBuf is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     CSL_Status              status;
 	     CSL_UartObj                uartObj;
         Uint32                  uartInstId;
         CSL_UartSetup 		     uartSetup;
         CSL_UartHandle hUart;
         Char  buf[12];
         Uint16 N = 12;
         uartInstId = 0;
 
         uartSetup.afeEnable = CSL_UART_NO_AFE;
         uartSetup.baud = 2400;
         uartSetup.clkInput = 60000000;
         uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
         uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
         uartSetup.parity =  CSL_UART_DISABLE_PARITY;
         uartSetup.rtsEnable = CSL_UART_NO_RTS;
         uartSetup.stopBits = 0;
         uartSetup.wordLength = CSL_UART_WORD8;

         status = UART_init(&amp;uartObj,uartInstId);
         hUart = (CSL_UartHandle)&amp;uartObj;
         status = UART_setup( hUart,&amp;uartSetup);
         status = UART_read(hUart,buf,N,1000) ;            
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="csl__error_8h.html#a5bf9c47547e0e302c43e3519537ff167">CSL_EUART_TIMEOUT</a>, <a class="el" href="structCSL__UartObj.html#a104ca1045f2a994afa51e5d126c3081e">CSL_UartObj::opmode</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#ga1870e020cef4ea6c19a3407f11676ebf">UART_getDataReadyStatus()</a>, <a class="el" href="group__CSL__UART__ENUM.html#ggadb8f91c9e0a2a604d5a85fb25e0a5e1cac2fe8f94bd88a9bf8b28df9c024ee963">UART_POLLED</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga60e5fe44b9617fe1eee1ba9f94def436"></a><!-- doxytag: member="csl_uart.h::UART_reset" ref="ga60e5fe44b9617fe1eee1ba9f94def436" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_reset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_reset</b> </p>
<p><b>Description</b> <br/>
 This API is used to reset the UART receiver and transmitter.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setupBaudRate call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 uart receiver and transmitter are in reset state.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     CSL_Status              status;
 	     CSL_UartObj                uartObj;
         CSL_UartHandle             hUart;
         Uint32                  uartInstId;
         Bool                    brecvstatus;
         Bool                    bxmitstatus;
         uartInstId = 0;
	     status = UART_init(&amp;uartObj,uartInstId);
         hUart = CSL_UartHandle(&amp;uartObj);
	     status = UART_resetOff(hUart);
	     status = UART_reset(hUart);
         brecvstatus = UART_getRecvorResetStatus(hUart);
         bxmitstatus = UART_getXmitorResetState(hUart);

     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_reset</b> </p>
<p><b>Description</b> <br/>
 This API is used to reset the UART receiver and transmitter.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setupBaudRate call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 uart receiver and transmitter are in reset state.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     CSL_Status              status;
 	     CSL_UartObj                uartObj;
         CSL_UartHandle             hUart;
         CSL_UartConfig             Config;            
         Uint32                  uartInstId;
         Bool                    brecvstatus; 
         Bool                    bxmitstatus; 
         uartInstId = 0;
         Config.FCR = CSL_UART_FIFO_DMA1_DISABLE_TRIG01;
         Config.DLL = 0x001b;
         Config.DLH = 0x0006;
         Config.LCR = 0x0003 
         Config.MCR = 0x0000;
	     status = UART_init(&amp;uartObj,uartInstId);
         hUart  = CSL_UartHandle(&amp;uartObj);
         status = UART_reset(hUart);	  
         status = UART_config(hUart,&amp;Config);   
         status = UART_resetOff(hUart);
         brecvstatus = UART_getRecvorResetStatus(hUart);
         bxmitstatus = UART_getXmitorResetState(hUart);
 
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga557bdcf804b5ce4d973a51342e459c67"></a><!-- doxytag: member="csl_uart.h::UART_resetOff" ref="ga557bdcf804b5ce4d973a51342e459c67" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_resetOff </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_resetOff</b> </p>
<p><b>Description</b> <br/>
 This API is used to set the UART receiver and transmitter.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setupBaudRate call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 uart receiver and transmitter are on state.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		 CSL_Status              status;
 	     CSL_UartObj                uartObj;
         CSL_UartHandle             hUart;
         Uint32                  uartInstId;
         Bool                    brecvstatus;
         Bool                    bxmitstatus;
         uartInstId = 0;
	     status = UART_init(&amp;uartObj,uartInstId);
         hUart = CSL_UartHandle(&amp;uartObj);
	     status = UART_resetOff(hUart);
         brecvstatus = UART_getRecvorResetStatus(hUart);
         bxmitstatus = UART_getXmitorResetState(hUart);
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_resetOff</b> </p>
<p><b>Description</b> <br/>
 This API is used to set the UART receiver and transmitter.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setupBaudRate call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 uart receiver and transmitter are on state.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status              status;
 	     CSL_UartObj                uartObj;
         CSL_UartHandle             hUart;
         Uint32                  uartInstId;
         Bool                    brecvstatus; 
         Bool                    bxmitstatus; 
         uartInstId = 0;
         config.FCR = CSL_UART_FIFO_DMA1_DISABLE_TRIG01;
         config.DLL = 0x001b;
         config.DLH = 0x0006;
         config.LCR = 0x0003 
         config.MCR = 0x0000;
	     status = UART_init(&amp;uartObj,uartInstId);
         hUart  = CSL_UartHandle(&amp;uartObj);
         status = UART_reset(hUart);	  
         status = UART_config(hUart,&amp;Config);   
         status = UART_resetOff(hUart);
         brecvstatus = UART_getRecvorResetStatus(hUart);
         bxmitstatus = UART_getXmitorResetState(hUart);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga576ad50502353e36e7e5cec5b048574f"></a><!-- doxytag: member="csl_uart.h::UART_setCallback" ref="ga576ad50502353e36e7e5cec5b048574f" args="(CSL_UartHandle hUart, CSL_UartIsrAddr *isrAddr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_setCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UartIsrAddr.html">CSL_UartIsrAddr</a> *&#160;</td>
          <td class="paramname"><em>isrAddr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_setCallback</b> </p>
<p><b>Description</b> <br/>
 UART_setCallback will set call back functions in isrDispatchTable.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 		hUart - Handle to the UART.
 		isrAddr - pointer to the 	CSL_UartIsrAddr.
      </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setCallback call is successful. <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 Setup call back functions in the UART_isrDispatchTable</li>
</ul>
<p><b>Modifies</b> <br/>
 hUart <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     CSL_Status              status;
 	     CSL_UartObj                uartObj;
            Uint32                      uartInstId;
            CSL_UartHandle 		 hUart;
            CSL_UartIsrAddr 		isrAddr;
            uartInstId = 0;

            status =  UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status =   UART_setCallback(hUart,&amp;isrAddr);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartIsrAddr.html#ab45ac9d8e97a0f787629576cd9702192">CSL_UartIsrAddr::ctoi</a>, <a class="el" href="structCSL__UartIsrAddr.html#a17af6ef5e67f9ac88978b29fe1a6b8f4">CSL_UartIsrAddr::lsiAddr</a>, <a class="el" href="structCSL__UartIsrAddr.html#aff06f5005b83c0287de5bce04cd67053">CSL_UartIsrAddr::rbiAddr</a>, <a class="el" href="structCSL__UartIsrAddr.html#aef71212fc94f632c23c067754d8e9571">CSL_UartIsrAddr::tbeiAddr</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#gad4d1a4c0a71614ea2b0d75379fa83379">UART_EVT_CTOI_IID</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#gaab4730ee4a6094888f4fcdaa39847d34">UART_EVT_LSI_IID</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga6e4f9282dd946c2f65e9650390542077">UART_EVT_RBI_IID</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga3bd5efb1d697a203e4a1027070aec5f4">UART_EVT_TBEI_IID</a>, and <a class="el" href="structCSL__UartObj.html#a2ea27faca61cba6ce4827033501c61c2">CSL_UartObj::UART_isrDispatchTable</a>.</p>

</div>
</div>
<a class="anchor" id="gae6c660c2eb268feba198a9772ef5be12"></a><!-- doxytag: member="csl_uartAux.h::UART_setToIntMode" ref="gae6c660c2eb268feba198a9772ef5be12" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status UART_setToIntMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_setToIntMode</b> </p>
<p><b>Description</b> <br/>
 This API is used to set the interrupt mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_ESYS_BADHANDLE - Invalid handle.</li>
</ul>
<ul>
<li>CSL_SOK - Changed to interruptmode.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         uartInstId = 0;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         status = UART_setToIntMode(hUart);


     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a104ca1045f2a994afa51e5d126c3081e">CSL_UartObj::opmode</a>, and <a class="el" href="group__CSL__UART__ENUM.html#ggadb8f91c9e0a2a604d5a85fb25e0a5e1ca6f851f4392c1b2736753ccb9cb249e15">UART_INTERRUPT</a>.</p>

</div>
</div>
<a class="anchor" id="ga8a905d6ea873b831a2512e80092bc256"></a><!-- doxytag: member="csl_uartAux.h::UART_setToPollMode" ref="ga8a905d6ea873b831a2512e80092bc256" args="(CSL_UartHandle hUart)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status UART_setToPollMode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_setToPollMode</b> </p>
<p><b>Description</b> <br/>
 This API is used to switch to the poll mode.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hUart        Handle to the uart
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_ESYS_BADHANDLE - Invalid handle.</li>
</ul>
<ul>
<li>CSL_SOK - Successfully changed to poll mode.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 UART_init should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 none</p>
<p><b>Modifies</b> <br/>
 none</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

         CSL_Status              	status;
         CSL_UartObj         		    uartObj;
         CSL_UartHandle            	hUart;
         Uint32                  	uartInstId;
         uartInstId = 0;
         status = UART_init(&amp;uartObj,uartInstId);
         hUart = &amp;uartObj;
         status = UART_setToPollMode(hUart);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UartObj.html#a104ca1045f2a994afa51e5d126c3081e">CSL_UartObj::opmode</a>, and <a class="el" href="group__CSL__UART__ENUM.html#ggadb8f91c9e0a2a604d5a85fb25e0a5e1cac2fe8f94bd88a9bf8b28df9c024ee963">UART_POLLED</a>.</p>

</div>
</div>
<a class="anchor" id="ga2c72ae773c3641614cf81c8cba0e8866"></a><!-- doxytag: member="csl_uart.h::UART_setup" ref="ga2c72ae773c3641614cf81c8cba0e8866" args="(CSL_UartHandle hUart, CSL_UartSetup *uartSetup)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_setup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UartSetup.html">CSL_UartSetup</a> *&#160;</td>
          <td class="paramname"><em>uartSetup</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_setup</b> </p>
<p><b>Description</b> <br/>
 The main function of this API is to setup the baud rate,configure fifo,enable transmitter and receiver UART setup word size,stop bits and parity.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
        uartSetup     Pointer to the UART_Setup structure.
     </pre></div><p> <b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setup call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid uartSetup <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 Setup the UART for transmission and reception.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status       status;
 	    CSL_UartObj         uartObj;
        Uint32           uartInstId;
        CSL_UartSetup 		 uartSetup;
        uartInstId = 0;
	    status = UART_init(&amp;uartObj,uartInstId);
        status =  UART_setup(CSL_UartHandle hUart,&amp;uartSetup);
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_setup</b> </p>
<p><b>Description</b> <br/>
 The main function of this API is to setup the baud rate,configure fifo,enable transmitter and receiver UART setup word size,stop bits and parity.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
        uartSetup     Pointer to the CSL_UartSetup structure.
     </pre></div><p> <b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setup call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid uartSetup <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 Setup the UART for transmission and reception.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status       status;
 	    CSL_UartObj         uartObj;
        Uint32           uartInstId;
        CSL_UartSetup 		 uartSetup;
        uartInstId = 0;
 
	    status = UART_init(&amp;uartObj,uartInstId);
        uartSetup.afeEnable = CSL_UART_NO_AFE;
        uartSetup.baud = 2400;
        uartSetup.clkInput = 60000000;
        uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
        uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
        uartSetup.parity =  CSL_UART_DISABLE_PARITY;
        uartSetup.rtsEnable = CSL_UART_NO_RTS;
        uartSetup.stopBits = 0;
        uartSetup.wordLength = CSL_UART_WORD8;
 
        status =  UART_setup(CSL_UartHandle hUart,&amp;uartSetup);
     </pre></div><p> ============================================================================ </p>

<p><p>Putting UART recvor and xmittor in reset state </p>
</p>

<p>References <a class="el" href="structCSL__UartSetup.html#a28d6cb8b2f57b239e5577afedaacc174">CSL_UartSetup::afeEnable</a>, <a class="el" href="structCSL__UartSetup.html#aef0a1b0cf8b06d4fe26f30f5400fcf89">CSL_UartSetup::baud</a>, <a class="el" href="structCSL__UartSetup.html#a002876d1caa334294e734ead2e2982da">CSL_UartSetup::clkInput</a>, <a class="el" href="csl__error_8h.html#aa8b4bdb5245fb647f33b307dc9fe1772">CSL_EUART_INVALID_WORDLENGTH</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga5c819774cd81f83dc33e946373217e64">CSL_UART_CLK_DIVIDER</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#gad1fa2d4f9eef518dc6eda85be4c470c8">CSL_UART_DISABLE_PARITY</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga241920308f6422fc42a64867896f4cdb">CSL_UART_EVEN_PARITY</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga1d80082357345e99eb63a891f1fac1db">CSL_UART_MARK_PARITY</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga9d67ac19719650d5d15e2ddd2f8e0b3a">CSL_UART_ODD_PARITY</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga72f8cbe970a4f9b51db8517625f778e8">CSL_UART_SPACE_PARITY</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga79e55a8a2011fc5795776e9e4be3cd82">CSL_UART_WORD5</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga3cf8880c2adff6da7b8a16d24d0f668d">CSL_UART_WORD6</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#gaa569e1ed5e1330226eab82fd43cbcf0b">CSL_UART_WORD7</a>, <a class="el" href="group__CSL__UART__SYMBOL.html#ga38beb06ee6a2425da471c4afa3ea7e7e">CSL_UART_WORD8</a>, <a class="el" href="structCSL__UartSetup.html#a1c37a674ade93a921ca80a1f50cfbda4">CSL_UartSetup::fifoControl</a>, <a class="el" href="structCSL__UartSetup.html#ab80a4470651ca5470a607b9a8a057c6c">CSL_UartSetup::loopBackEnable</a>, <a class="el" href="structCSL__UartSetup.html#abc58aebb651f5ad2f2fc5e65bee86812">CSL_UartSetup::parity</a>, <a class="el" href="structCSL__UartSetup.html#aa9aed8faf466c40af1152e86732dded3">CSL_UartSetup::rtsEnable</a>, <a class="el" href="structCSL__UartSetup.html#a1f39e291b139d196c54654e72fbb0580">CSL_UartSetup::stopBits</a>, <a class="el" href="structCSL__UartObj.html#a58c0ca2c9fa0c69f929bbde55493cdff">CSL_UartObj::trigLevel</a>, <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>, and <a class="el" href="structCSL__UartSetup.html#a7b8365624d311a5ab10d3b0bf33834b8">CSL_UartSetup::wordLength</a>.</p>

</div>
</div>
<a class="anchor" id="ga342a469aaff711aebaec48ca0728cf19"></a><!-- doxytag: member="csl_uart.h::UART_setupBaudRate" ref="ga342a469aaff711aebaec48ca0728cf19" args="(CSL_UartHandle hUart, Uint32 clkInput, Uint32 baudRate)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_setupBaudRate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>clkInput</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>baudRate</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_setupBaudRate</b> </p>
<p><b>Description</b> <br/>
 This API is used to set the baud rate.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart       Handle to the UART
        clkInput    Input clock frequency in Hz
        baudRate    Baud rate.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setupBaudRate call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init should be called successfully. <b> Post Condition </b> <br/>
 DLL and DLH registers are set.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status              status;
 	    CSL_UartObj                uartObj;
        Uint32                  uartInstId;
        UART_baud 		        uartBaud;
        uartInstId = 0;

	    status = UART_init(&amp;uartObj,uartInstId);
        uartBaud.clkInput = 60000000;
        uartBaud.baudRate = 2400;
        status =  UART_setupBaudRate(CSL_UartHandle hUart,&amp;Config);
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_setupBaudRate</b> </p>
<p><b>Description</b> <br/>
 This API is used to set the baud rate.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart       Handle to the UART
        clkInput    Input clock frequency in Hz
        baudRate    Baud rate.  
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_setupBaudRate call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 DLL and DLH registers are set to clkdivisor value.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
		CSL_Status              status;
 	    CSL_UartObj                uartObj;
        CSL_UartHandle             hUart;
        Uint32                  uartInstId;        
        CSL_UartSetup              uartSetup;            
        uartInstId = 0;
 
        uartSetup.afeEnable = CSL_UART_NO_AFE;
        uartSetup.baud = 2400;
        uartSetup.clkInput = 60000000;
        uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
        uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
        uartSetup.parity =  CSL_UART_DISABLE_PARITY;
        uartSetup.rtsEnable = CSL_UART_NO_RTS;
        uartSetup.stopBits = 0;
        uartSetup.wordLength = CSL_UART_WORD8;

	    status = UART_init(&amp;uartObj,uartInstId);        
        hUart  = (CSL_UartHandle)&amp;uartObj;
        status = UART_setup(hUart,&amp;uartSetup);        
        status = UART_setupBaudRate(hUart,60000000,4800);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__UART__SYMBOL.html#ga5c819774cd81f83dc33e946373217e64">CSL_UART_CLK_DIVIDER</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
<a class="anchor" id="ga3c28d5d2a132b3722794c437018fc91a"></a><!-- doxytag: member="csl_uart.h::UART_write" ref="ga3c28d5d2a132b3722794c437018fc91a" args="(CSL_UartHandle hUart, Char *pBuf, Uint16 count, Uint32 timeout)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status UART_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UartObj.html">CSL_UartHandle</a>&#160;</td>
          <td class="paramname"><em>hUart</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Char *&#160;</td>
          <td class="paramname"><em>pBuf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>UART_write</b> </p>
<p><b>Description</b> <br/>
 UART_write writes up to count characters to the THR(Transmitter Holding Register) from the buffer starting at pBuf</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
		pBuf   Input buffer
        count  No of characters to write.
        timeout Timeout value
                0 - wait indefinitely for THRE bit to get set.
                x - wait x value for THRE bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_write call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid address of the pBuf </li>
<li>CSL_EUART_TIMEOUT - Write had a timeout due to THRE bit not set. <b> Pre Condition </b> <br/>
 UART_init and <a class="el" href="structCSL__UartSetup.html" title="UART Setup structure.">CSL_UartSetup</a> should be called successfully. <b> Post Condition </b> <br/>
 count number of characters have written to THR.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            Uint32                      uartInstId;
            CSL_UartSetup 		 uartSetup;
            CSL_UartHandle hUart;
            Char  buf[12];
            Uint16 N = 12;
            uartInstId = 0;

            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status =  CSL_UartSetup( hUart,&amp;uartSetup);
            status = UART_write(hUart,buf,N,1000) ;
     </pre></div><p> ============================================================================</p>
<p>============================================================================ <br/>
<b>UART_write</b> </p>
<p><b>Description</b> <br/>
 UART_write writes up to count characters to the THR(Transmitter Holding Register) from the buffer starting at pBuf In interrupt mode maximum of 16 charaters it will write <b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
		hUart  Handle to the UART.
		pBuf   Input buffer
        count  No of characters to write.
        timeout Timeout value
                0 - wait indefinitely for THRE bit to get set.
                x - wait x value for THRE bit to get set.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - UART_write call is successful </li>
<li>CSL_ESYS_BADHANDLE- Invalid UART Handle </li>
<li>CSL_ESYS_INVPARAMS- Invalid address of the pBuf </li>
<li>CSL_EUART_TIMEOUT - Write had a timeout due to THRE bit not set. <b> Pre Condition </b> <br/>
 UART_init and UART_setup should be called successfully. <b> Post Condition </b> <br/>
 count number of characters are written to THR.</li>
</ul>
<p><b>Modifies</b> <br/>
 Handle is modified <b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 	     	CSL_Status              status;
 	     	CSL_UartObj                uartObj;
            Uint32                  uartInstId;
            CSL_UartSetup 		        uartSetup;
            CSL_UartHandle             hUart;
            Char                    buf[12];
            Uint16 N = 12;
            uartInstId = 0;

            uartSetup.afeEnable = CSL_UART_NO_AFE;
            uartSetup.baud = 2400;
            uartSetup.clkInput = 60000000;
            uartSetup.fifoControl = CSL_UART_FIFO_DISABLE;
            uartSetup.loopBackEnable = CSL_UART_NO_LOOPBACK;
            uartSetup.parity =  CSL_UART_DISABLE_PARITY;
            uartSetup.rtsEnable = CSL_UART_NO_RTS;
            uartSetup.stopBits = 0;
            uartSetup.wordLength = CSL_UART_WORD8;

            status = UART_init(&amp;uartObj,uartInstId);
            hUart = (CSL_UartHandle)&amp;uartObj;
            status =  UART_setup( hUart,&amp;uartSetup);
            status = UART_write(hUart,buf,N,1000) ;            
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="csl__error_8h.html#a5bf9c47547e0e302c43e3519537ff167">CSL_EUART_TIMEOUT</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga482046cb8c1140e3d8cd5f778f698591a789b2d692d2de80e25b65362c4d4ccb4">CSL_UART_FIFO_MODE</a>, <a class="el" href="group__CSL__UART__ENUM.html#gga482046cb8c1140e3d8cd5f778f698591a652890174b2e0c5e2c85efbe6df01443">CSL_UART_NON_FIFO_MODE</a>, <a class="el" href="structCSL__UartObj.html#a104ca1045f2a994afa51e5d126c3081e">CSL_UartObj::opmode</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#ga7a7de8a5a9d94678c8eb024e072ee2eb">UART_getModeOfTransfer()</a>, <a class="el" href="group__CSL__UART__FUNCTION.html#gac0abd3e3b415c26bd42a8c00ba9fe7cd">UART_getXmitHoldRegEmptyStatus()</a>, <a class="el" href="group__CSL__UART__ENUM.html#ggadb8f91c9e0a2a604d5a85fb25e0a5e1cac2fe8f94bd88a9bf8b28df9c024ee963">UART_POLLED</a>, and <a class="el" href="structCSL__UartObj.html#a2a308b1e8e277693d429708ff2537ea9">CSL_UartObj::uartRegs</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jun 23 2011 15:25:55 for C55XX CSL Version 2.50 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
