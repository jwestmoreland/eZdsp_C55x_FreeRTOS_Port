<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>C55XX CSL EXAMPLE: I2C EXAMPLE DOCUMENTATION</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.4 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">C55XX CSL EXAMPLE</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">I2C EXAMPLE DOCUMENTATION </div>  </div>
</div>
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="I2C1"></a>
I2C EXAMPLE1 - POLL MODE TEST</h2>
<h3><a class="anchor" id="I2C1x"></a>
TEST DESCRIPTION:</h3>
<p>This test verifies the operation of CSL I2C module in polled mode.</p>
<p>During the test 64 bytes of data is written to EEPROM page and is read back using the CSL I2C APIs. I2C module will be configured to master mode, 7-bit addressing and 10KHz bus frequency using I2C_setup() API. EEPROM page with address 0x0000 is written using the I2C_write() API. Data buffer 'gI2cWrBuf' is used to store the data to be written to EEPROM page. Address of the page to be written is stored in the first two bytes of the I2C write buffer. So the data length passed to the write API should be 66 bytes. Address of the slave device (0x50 for EEPROM) should be passed to the write API.</p>
<p>Reading the data from the EEPROM page will be done in two steps. In first step address of the EEPROM page to be read is written using I2C_write API. This operation will be same as data write operation except that the length of the data will be 2 bytes. After writing the EEPROM page address data should be read from that EEPROM page using I2C_read() API. Data read from the EEPROM page is stored in the buffer 'gI2cRdBuf'. Slave device address and data length to be read should be passed to the I2C_read() API. Here the data length should be 64 bytes. After successful completion of the write and read operations data buffers are compared to verify the success of the operations.</p>
<p>I2C operates at all the system clock frequencies. Value of the system clock at which CPU is running during the test should be passed to the I2C_setup() function. This will be used to calculate I2C clock and prescaler values. 'CSL_I2C_SYS_CLK' macro is defined with different system clock values. Depending on the system clock value corresponding value definition of the macro should be uncommented and re-build the project for proper operation of the test.</p>
<p>Both read and write APIs are synchronous and returns to the application only after completing the data transfer. A small delay is required after each data operation to allow the device to get ready for the next operation.</p>
<p>NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSIONS C5505 AND C5515. MAKE SURE THAT PROPER CHIP VERSION MACRO IS DEFINED IN THE FILE c55xx_csl\inc\csl_general.h.</p>
<h3><a class="anchor" id="I2C1y"></a>
TEST PROCEDURE:</h3>
<ul>
<li>Open the CCS and connect the target (C5505/C5515 EVM) </li>
<li>Open the project "CSL_I2C_PollExample_Out.pjt" and build it </li>
<li>Load the program on to the target </li>
<li>Set the PLL frequency to 12.288MHz </li>
<li>Run the program and observe the test result </li>
<li>Repeat the test at PLL frequencies 40, 60, 75 and 100MHz </li>
<li>Repeat the test in Release mode</li>
</ul>
<h3><a class="anchor" id="I2C1z"></a>
TEST RESULT:</h3>
<ul>
<li>All the CSL APIs should return success </li>
<li>Read and write data buffer comparison should be successful.</li>
</ul>
<p>============================================================================</p>
<h2><a class="anchor" id="I2C2"></a>
I2C EXAMPLE2 - DMA MODE TEST</h2>
<h3><a class="anchor" id="I2C2x"></a>
TEST DESCRIPTION:</h3>
<p>This test verifies the operation of CSL I2C module in DMA mode. In DMA mode of operation CSL DMA module is used to transfer the data between CPU memory and I2C registers.</p>
<p>During the test 64 bytes of data is written to EEPROM page and is read back using the DMA module. CSL DMA module needs to be initialized and configured for I2C read and write operations before configuring the I2C module. On C5505 DSP DMA swaps the words in the source buffer before transferring it to the destination. No data mismatch is observed When both write and read operations are done in DMA mode as the word swap occurs in both the operations. There will be data mismatch if data write is in DMA mode and read is in polling mode or vice versa. In case of I2C this word swap does not take effect due to 8 bit data access of the I2C hardware. I2C module generates a DMA event for each byte of data transfer but DMA transfers 4 bytes for each I2C event. To synchronize the I2C events and DMA transfers data is stored in 32 buffer with only 8 bits having valid data and other bits will have zeros. I2C will be configured for N bytes and DMA will be configured for 4*N bytes of data transfers. Due this specific buffer allocation and configuration, only one byte will be valid data out of four bytes transferred by DMA for each I2C event. This DMA word swap is eliminated in the chip version C5515.</p>
<p>Due to big endianness of the C5505/C5515 DSP a value 0x00000001 assigned to 32 bit buffer will be stored in memory as 0x0000 and 0x0001. During data transfer DMA swaps the words and writes 0x0001 in lower 16 bit address and 0x0000 in upper 16 bits address. The value 0x0000 written in upper 16 bit address will be ignored by I2C since Tx and Rx registers are only 16 bit wide.</p>
<p>I2C module will be configured to master mode, 7-bit addressing 10KHz bus frequency using I2C_config() API. Slave address, data length and data command should be passed to the I2C_config API. Data buffer 'gI2cWrBuf' is used to store the data to be written to EEPROM page. Address of the page to be written is stored in the first two bytes of the I2C write buffer. So the data length passed to the I2C_config API should be 66 bytes. I2C start bit is set to one to enable the I2C data transfer DMA event generation. DMA data transfer on the channel configured for I2C transmit will be started by using DMA_start() API. DMA data transfer completion is detected using DMA_getStatus() API. This completes the I2C write operation.</p>
<p>Reading the data from the EEPROM page will be done in two steps. In first step address of the EEPROM page to be read is written to the EEPROM. This operation will be same as data write operation except that the length of the data will be 2 bytes. After writing the EEPROM page address I2C should be configured for read operation using I2C_config() API. Configuring the I2C for read or write depends on the value sent to the I2C command register. I2C start bit is set to one to enable the I2C data receive DMA event generation. DMA data transfer on the channel configured for I2C receive will be started by using DMA_start() API. DMA data transfer completion is detected using DMA_getStatus() API. This completes the I2C read operation. After successful completion of the write and read operations write and read buffers are compared for data verification.</p>
<p>Small amount of delay is required after each data operation to allow the I2C device to get ready for next data operation. In DMA mode of operation I2C data buffers should be of type Uint32.</p>
<p>NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSIONS C5505 AND C5515. MAKE SURE THAT PROPER CHIP VERSION MACRO IS DEFINED IN THE FILE c55xx_csl\inc\csl_general.h.</p>
<h3><a class="anchor" id="I2C2y"></a>
TEST PROCEDURE:</h3>
<ul>
<li>Open the CCS and connect the target (C5505/C5515 EVM) </li>
<li>Open the project "CSL_I2C_DmaExample_Out.pjt" and build it </li>
<li>Load the program on to the target </li>
<li>Set the PLL frequency to 12.288MHz </li>
<li>Run the program and observe the test result </li>
<li>Repeat the test at PLL frequencies 40, 60, 75 and 100MHz </li>
<li>Repeat the test in Release mode</li>
</ul>
<h3><a class="anchor" id="I2C2z"></a>
TEST RESULT:</h3>
<ul>
<li>All the CSL APIs should return success </li>
<li>Read and write data buffer comparison should be successful.</li>
</ul>
<p>============================================================================</p>
<h2><a class="anchor" id="I2C3"></a>
I2C EXAMPLE3 - INTERRUPT MODE TEST</h2>
<h3><a class="anchor" id="I2C3x"></a>
TEST DESCRIPTION:</h3>
<p>This test verifies the operation of CSL I2C module in interrupt mode.</p>
<p>During the test 64 bytes of data is written to EEPROM page and is read back using the CSL I2C APIs and I2C data callback functions. Interrupts are used to indicate the device ready status for a byte of data transmit or receive operation. CSL INTC module should be configured and I2C ISR should be registered before starting the data transfer. I2C callback functions which are called from the Interrupt Service Routine should be configured using I2C_setCallback() API. I2C module will be configured to master mode, 7-bit addressing and 10KHz bus frequency using I2C_config() API. I2C own address, data length, clock values, data command should be sent to the I2C config API. Data buffer 'gI2cWrBuf' is used to store the data to be written to EEPROM page. Address of the page to be written is stored in the first two bytes of the I2C write buffer. So the data length sent to the config API should be 66 bytes. after configuring the I2C module, interrupts for I2C transmit and No Acknowledgement error will be enabled and I2C data transfer will be triggered by setting the start bit. I2C will start generating the transmit interrupts. One byte of data will be copied to the I2C data transmit register in the I2C transmit callback function for each interrupt generated. After completing the transfer of 66 bytes I2C interrupts will be disabled. This completes the EEPROM page write.</p>
<p>Reading the data from the EEPROM page will be done in two steps. In first step address of the EEPROM page to be read is written to the EEPROM. This operation will be same as data write operation except that the length of the data will be 2 bytes. After writing the EEPROM page address I2C will be configured for data read using I2C_config() API. I2C receive ready interrupt is enabled and I2C data reception is started by setting the start bit. I2C starts generating read interrupts. I2C read callback function will read one byte of data from I2C read register for each interrupt generated. Data read from the EEPROM page is stored in the buffer 'gI2cRdBuf'. After reading 64 bytes of data I2C interrupts will be disabled. This completes I2C read operation. After successful completion of the write and read operations data buffers are compared to verify the success of the operations.</p>
<p>A small delay is required after each data operation to allow the device get ready for next data transfer operation.</p>
<p>NOTE: TEST SHOULD NOT BE RUN BY SINGLE STEPPING AFTER ENABLING THE I2C INTERRUPTS. DOING SO WILL LEAD TO IMPROPER HANDLING OF THE INTERRUPTS AND TEST FAILURE.</p>
<p>NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSIONS C5505 AND C5515. MAKE SURE THAT PROPER CHIP VERSION MACRO IS DEFINED IN THE FILE c55xx_csl\inc\csl_general.h.</p>
<h3><a class="anchor" id="I2C3y"></a>
TEST PROCEDURE:</h3>
<ul>
<li>Open the CCS and connect the target (C5505/C5515 EVM) </li>
<li>Open the project "CSL_I2C_IntcExample_Out.pjt" and build it </li>
<li>Load the program on to the target </li>
<li>Set the PLL frequency to 12.288MHz </li>
<li>Run the program and observe the test result </li>
<li>Repeat the test at PLL frequencies 40, 60, 75 and 100MHz </li>
<li>Repeat the test in Release mode</li>
</ul>
<h3><a class="anchor" id="I2C3z"></a>
TEST RESULT:</h3>
<ul>
<li>All the CSL APIs should return success </li>
<li>Read and write buffer comparison should be successful.</li>
</ul>
<p>============================================================================</p>
<h2><a class="anchor" id="I2C4"></a>
I2C EXAMPLE4 - LOOPBACK MODE TEST</h2>
<h3><a class="anchor" id="I2C4x"></a>
TEST DESCRIPTION:</h3>
<p>This test verifies the operation of CSL I2C module in loopback mode. In loopback mode I2C module does not communicate with any slave device. Internally I2C transmit register will be connected to the I2C receive register. Any data copied to the I2C transmitted data will be transmitted to the I2C receive registers. Loopback mode is helpful to verify the I2C data and shift registers and internals data paths.</p>
<p>During the test one byte of data is written to the I2C transmit register and the same is read from the I2C receive register. I2C module will be configured to loopback mode, 7-bit addressing and 10KHz bus frequency using I2C_config() API. Data buffer 'gI2cWrBuf' is used to store the data to be written to I2C transmit register. Data buffer 'gI2cRdBuf' is used to store the data read from the I2C receive register. After configuring the I2C module one byte of data is written to I2C using a macro 'CSL_I2C0_WRITEREG' and one byte of data is read from I2C using 'CSL_I2C0_READREG'. A small delay is required between write and read operation to allow the data get loopbacked. This write-read operation is repeated for 64 bytes. After tranferring the 64 bytes read and write buffers are compared for data verification.</p>
<p>NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSIONS C5505 AND C5515. MAKE SURE THAT PROPER CHIP VERSION MACRO IS DEFINED IN THE FILE c55xx_csl\inc\csl_general.h.</p>
<h3><a class="anchor" id="I2C4y"></a>
TEST PROCEDURE:</h3>
<ul>
<li>Open the CCS and connect the target (C5505/C5515 EVM) </li>
<li>Open the project "CSL_I2C_LoopbackExample_Out.pjt" and build it </li>
<li>Load the program on to the target </li>
<li>Set the PLL frequency to 12.288MHz </li>
<li>Run the program and observe the test result </li>
<li>Repeat the test at PLL frequencies 40, 60, 75 and 100MHz </li>
<li>Repeat the test in Release mode</li>
</ul>
<h3><a class="anchor" id="I2C4z"></a>
TEST RESULT:</h3>
<ul>
<li>All the CSL APIs should return success </li>
<li>Read and write data buffer comparison should be successful.</li>
</ul>
<p>============================================================================</p>
<h2><a class="anchor" id="I2C5"></a>
I2C EXAMPLE5 - DMA WORD SWAP TEST</h2>
<h3><a class="anchor" id="I2C5x"></a>
TEST DESCRIPTION:</h3>
<p>This test verifies the operation of CSL I2C module with write in one operating mode and read in other operating mode. This test is conducted in two phases in first phase I2C write will be done in DMA mode and read will be done in polled mode. In second phase I2C write will be done in polled mode and read will be done in DMA mode. This test is to prove that the DMA word swap has no effect on the I2C data operations.</p>
<p>On C5505 DSP DMA swaps the words in the source buffer before transferring it to the destination. No data mismatch is observed when both write and read operations are done in DMA mode as the word swap occurs in both the operations. There will be data mismatch if data write is in DMA mode and read is in polling mode or vice versa. In case of I2C this word swap does not take effect due to 8 bit data access of the I2C hardware. I2C module generates a DMA event for each byte of data transfer but DMA transfers 4 bytes for each I2C event. To synchronize the I2C events and DMA transfers data is stored in 32 buffer with only 8 bits having valid data and other bits will have zeros. I2C will be configured for N bytes and DMA will be configured for 4*N bytes of data transfers. Due this specific buffer allocation and configuration, only one byte will be valid data out of four bytes transferred by DMA for each I2C event. This DMA word swap is eliminated in the chip version C5515.</p>
<p>Due to big endianness of the C5505/C5515 DSP a value 0x00000001 assigned to 32 bit buffer will be stored in memory as 0x0000 and 0x0001. During data transfer DMA swaps the words and writes 0x0001 in lower 16 bit address and 0x0000 in upper 16 bits address. The value 0x0000 written in upper 16 bit address will be ignored by I2C since Tx and Rx registers are only 16 bit wide.</p>
<p>During the first phase of the test 64 bytes of data is written to EEPROM page in DMA mode and read back in polled mode. I2C module will be configured to master mode, 7-bit addressing 10KHz bus frequency using I2C_config() API. Slave address, data length and data command should be passed to the I2C_config API. Data buffer 'gI2cDmaWrBuf' is used to store the data to be written to EEPROM page. I2C data transfer is started by setting the start bit and DMA data transfer is started using DMA_Start() API. DMA data transfer completion is detected using DMA_getStatus() API. This completes the I2C write in DMA mode. For reading the EEPROM page in polled mode address of the page will be written to the EEPROM in DMA mode. I2C is configured for read operation using I2C_config() API. EEPROM page is read by using the I2C_read() API. Data buffer 'gI2cPollRdBuf' is used to store the data read from the EEPROM page. This completes the I2C read operation in polled mode. After successful completion of write and read operations gI2cDmaWrBuf and gI2cPollRdBuf are compared for data verification.</p>
<p>During the second phase of the test 64 bytes of data is written to EEPROM page in polled mode and read back in DMA mode. I2C module will be configured to master mode, 7-bit addressing 10KHz bus frequency using I2C_setup() API. Data buffer 'gI2cPollWrBuf' is used to store the data to be written to EEPROM page. Data is written to the EEPROM page using I2C_write() API. This completes the I2C write in polled mode. For reading the EEPROM page in DMA mode address of the page will be written to the EEPROM in polled mode using I2C_write() API. I2C is configured for read operation using I2C_config() API. Data buffer 'gI2cDmaRdBuf' is used to store the data read from the EEPROM page. I2C data receive is started by setting the start bit and DMA data transfer is started using DMA_Start() API. DMA data transfer completion is detected using DMA_getStatus() API. This completes the I2C read operation in DMA mode. After successful completion of write and read operations gI2cPollWrBuf and gI2cDmaRdBuf are compared for data verification.</p>
<p>Small amount of delay is required after each data operation to allow the I2C device to get ready for next data operation. Data buffers allocated should be of type Uint16 for polled mode operation of type Uint32 for DMA mode of operation.</p>
<p>NOTE: THIS TEST HAS BEEN DEVELOPED TO WORK WITH CHIP VERSIONS C5505 AND C5515. MAKE SURE THAT PROPER CHIP VERSION MACRO IS DEFINED IN THE FILE c55xx_csl\inc\csl_general.h.</p>
<h3><a class="anchor" id="I2C5y"></a>
TEST PROCEDURE:</h3>
<ul>
<li>Open the CCS and connect the target (C5505/C5515 EVM) </li>
<li>Open the project "CSL_I2C_DmaWordSwapExapmle_Out.pjt" and build it </li>
<li>Load the program on to the target </li>
<li>Set the PLL frequency to 12.288MHz </li>
<li>Run the program and observe the test result </li>
<li>Repeat the test at PLL frequencies 40, 60, 75 and 100MHz </li>
<li>Repeat the test in Release mode</li>
</ul>
<h3><a class="anchor" id="I2C5z"></a>
TEST RESULT:</h3>
<ul>
<li>All the CSL APIs should return success </li>
<li>Read and write data buffer comparison should be successful. </li>
</ul>
</div></div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jun 23 2011 15:26:19 for C55XX CSL EXAMPLE by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
