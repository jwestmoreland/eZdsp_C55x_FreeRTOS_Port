<!-- This comment will put IE 6, 7 and 8 in quirks mode -->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>C55XX CSL Version 2.50: USB MUSB Functions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="$relpath/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="$relpath/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<table width="100%">
<tr>
  <td bgcolor="black" width="1"><a href="http://www.ti.com"><img border="0" src="tilogo.gif" /></a></td>
  <td bgcolor="red"><img src="titagline.gif" /></td>
</tr>
</table>
<!-- Generated by Doxygen 1.7.4 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">USB MUSB Functions</div>  </div>
<div class="ingroups"><a class="el" href="group__CSL__USB__API.html">USB</a></div></div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga8301a46f09b84292bca5a68b1b8bc087">USB_init</a> (<a class="el" href="structCSL__UsbConfig.html">CSL_UsbConfig</a> *usbConfig)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gae4c0648f5992d00af0cd4332bdde9cfe">USB_resetDev</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga46e5b8803934b3b426c6905f1caf88fb">USB_initEndptObj</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, <a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp, <a class="el" href="group__CSL__USB__ENUM.html#gadd63cd53e03e1d7e632a8cbe348e3401">CSL_UsbEpNum</a> epNum, <a class="el" href="group__CSL__USB__ENUM.html#ga66eb2483fddc8df328af8db4dca5cde0">CSL_UsbXferType</a> xferType, Uint16 maxPktSize, Uint16 evMask, <a class="el" href="group__CSL__USB__SYMBOL.html#ga8419caa096a0b04548542413363c1341">CSL_USB_EVENT_ISR</a> fxn)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga1177db34a8d022241109bc0dbfb2f0fb">USB_getEvents</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga4f33d1f861c059838d28ca10ce2fba5c">USB_peekEvents</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf93dedf9cb26d01cd9175311587739aa">USB_getSetupPacket</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, <a class="el" href="structCSL__UsbSetupStruct.html">CSL_UsbSetupStruct</a> *usbSetup, Bool readFromFifo)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gab8433a78959992028990dfb54b6f2489">USB_postTransaction</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp, Uint16 byteCnt, void *data, <a class="el" href="group__CSL__USB__SYMBOL.html#ga451c5b10120bc3d838c3768571f5255c">CSL_UsbIoFlags</a> flags)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga541ad4e3334474fa15bc0e41eb66a854">USB_isTransactionDone</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#gab3da07d7e14ff698e33affd67b90e462">CSL_UsbByteCount</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga326ecd2cba981840f9466939ac4f9a0e">USB_bytesRemaining</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga4367c71973487a2e9aa4f96b072f566a">USB_stallEndpt</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga41df2dbcad5ef0c2517641667661c50b">USB_clearEndptStall</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga4d61cd37fe4bd85380c09ec5838226c9">USB_getEndptStall</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp, CSL_Status *status)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf45935ea5e664abdc199e230db5cab5a">USB_epNumToHandle</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, Uint16 endpt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga47eea8c6fb9c13bcc592f48b86882e5f">USB_abortTransaction</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaa586eaec6263219ab634d012f7bcb5b7">USB_abortAllTransaction</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga99e256983f24a55e5ed37988b2414fb8">USB_connectDev</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gac545ae84457dd2de1c56a7767a0fc2f0">USB_disconnectDev</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga40bfe702ae4e80d307dee7c6bef7af52">USB_setRemoteWakeup</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, <a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> rmtWkpStat)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaede526f4445bcac9971b56772e6916af">USB_getRemoteWakeupStat</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf55f2386166ce85e5f8d9361bcc3d1af">USB_issueRemoteWakeup</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, Bool resumeBitVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga42bd3cd663ef1cf0adba13ef80005885">USB_setDevAddr</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, Uint16 addr)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__CSL__USB__SYMBOL.html#gaf3bbf88b130333432b790039b6caf5a3">CSL_UsbFrameNum</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga641caf33fe52120dfe8473c3f66b76ad">USB_getFrameNo</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga2fa2188b3893dc1dc78c63f7b5181b91">USB_suspendDevice</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga017f622aab04990632100eb52a86b9bb">USB_selfwakeup</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, Uint32 wakeupDelay)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga48dfe90c50e4929e45e5b6d700c6cf38">USB_initPLL</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaed27bb8e5240ac3c693aedf8f3016254">USB_setParams</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, <a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEpObj[], Uint16 pSofTmrCnt)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">WORD&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga810fdea6c6079a68858b9a46e3149b42">USB_getMaxPower</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga77da82b7f7cd6b40da44da48c6e0d09b">USB_setFullSpeedMode</a> (Uint16 ep0DataSize)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">Uint16&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaa04d261f321e73e926364bea30e17243">USB_getDataCountReadFromFifo</a> (<a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> hEp)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="gaccf21181239c5d490aa62f7da6bf36cf"></a><!-- doxytag: member="CSL_USB_FUNCTION::USB_findFifoSize" ref="gaccf21181239c5d490aa62f7da6bf36cf" args="(Uint16 maxPktSize, CSL_UsbXferType xferType)" -->
Uint16&#160;</td><td class="memItemRight" valign="bottom"><b>USB_findFifoSize</b> (Uint16 maxPktSize, <a class="el" href="group__CSL__USB__ENUM.html#ga66eb2483fddc8df328af8db4dca5cde0">CSL_UsbXferType</a> xferType)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf81115692729a4f51bdd61e391bde2f7">USB_swapWords</a> (Uint16 *dataBuffer, Uint32 dataLength)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga617c12b1a886b29e550e006556a4f379">USB_initDma</a> (void)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gaf1e70d7868d0da0abf71644d86863de0">USB_initQueueManager</a> (<a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *hpdtx, Uint32 *pLinkingRam)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga060b37017cf03824b93f431b550c8594">USB_dmaPopQue</a> (Uint16 queueNum)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga0ce6eaf5d8091633557b37df2bfae19a">USB_dmaRxStart</a> (DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gafddd09a5cff47ba64c04df2e55a80bff">USB_confDmaRx</a> (<a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *hpdrx, Uint32 packetsize, Uint16 *pRxBuffer)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gae6cebacc623d4ec4f8f9a8fcc0636d54">USB_confDmaTx</a> (<a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *hpdtx, Uint32 packetsize, Uint16 *pTxBuffer, Bool swapWords)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga20e4e8227fc3b0678345d88b40ff4bf0">USB_dmaRxStop</a> (DWORD dwEndpoint, Uint16 *pRxBuffer, Uint32 packetsize, Bool swapWords)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga114e2c5f9ce4007fb69ce865dd9d2a36">USB_dmaTxStart</a> (DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga3569b5b61f6d08666713987ccf3504d9">USB_dmaTxStop</a> (DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga955117b9b701aa36f76cb14f62dd8b94">USB_handleTx</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext, DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga0fc2062e6251f1b011e3aa3f0c3bf029">USB_handleRx</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext, DWORD dwEndpoint)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gab23a2e1141ef754e588258d3b79b482f">USB_processEP0Out</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static CSL_Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga42111aab09b38aaa869715afb5b08072">USB_processEP0In</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga790f2cfc0abc1797a32edfb05dcb720a">USB_handleRxIntr</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga8ceaaae01b4ecf3ea8b1600b753567b4">USB_handleTxIntr</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga4f9eaf8c608967c23b7608093476a6ac">USB_checkSpeed</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext, <a class="el" href="group__CSL__USB__ENUM.html#ga6220edfa1c5d35fdc5ccd13caf6e2abe">CSL_UsbBusSpeed</a> *pBusSpeed)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga3a745278253b3876c4e51a303d1df8a6">USB_readEP0Buf</a> (<a class="el" href="structCSL__UsbContext.html">pUsbContext</a> pContext, DWORD *pBuf)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga49c4ae738506de911efa58655cac46fc">USB_setConfiguration</a> (<a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a> devNum, Uint16 confVal)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static Bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#ga738d92af63ce8891b61a6b6f899bad78">USB_isValidDataInFifoOut</a> (<a class="el" href="structCSL__UsbEpStatus.html">pUsbEpStatus</a> peps)</td></tr>
<tr><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__CSL__USB__FUNCTION.html#gae70a92d926f2bb1fe4398a3c3d5da1e1">USB_flushFifo</a> (DWORD dwEndpoint, Bool fifoDirFlag)</td></tr>
</table>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="gaa586eaec6263219ab634d012f7bcb5b7"></a><!-- doxytag: member="csl_usb.h::USB_abortAllTransaction" ref="gaa586eaec6263219ab634d012f7bcb5b7" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_abortAllTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_abortAllTransaction</b> </p>
<p><b>Description</b> <br/>
 This function terminates all the data transfer in progress and free up the endpoints to post new data transfer requests.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_postTransaction function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Aborts all transactions in progress</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16    dadaBuf[256];

 			pUsbEpHandle    hEp;
            CSL_Status      status;

			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			.....
			.....
			status = USB_abortAllTransaction(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga084a56a2be6f658e477bc19731f33cd4">CSL_USB_ENDPOINT_COUNT</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga47eea8c6fb9c13bcc592f48b86882e5f">USB_abortTransaction()</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gaa9e8be4f850baf2c6bae1292ac84edd4">AC_Ctrl()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga459f0629c19b630ec9e5dccd30707da0">MSC_Ctrl()</a>.</p>

</div>
</div>
<a class="anchor" id="ga47eea8c6fb9c13bcc592f48b86882e5f"></a><!-- doxytag: member="csl_usb.h::USB_abortTransaction" ref="ga47eea8c6fb9c13bcc592f48b86882e5f" args="(pUsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_abortTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_abortTransaction</b> </p>
<p><b>Description</b> <br/>
 This function terminates the data transfer in progress and free up the endpoint to post a new data transfer request.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_postTransaction function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Terminates data transfer in progress</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			Uint16    dadaBuf[256];

 			pUsbEpHandle    hEp;
            CSL_Status      status;

			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			.....
			.....
			status = USB_abortTransaction(hEp);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbEpStatus.html#a52b4b4145359b2eb9d80791795c35ac0">CSL_UsbEpStatus::fInitialized</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, and <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__MSC__FUNCTION.html#ga3bb637bcc9bbee4ed2ac72a64402931a">MSC_HandleStateReset()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga1c84b3ba9ecdb8f1cf79a5be77fae23f">MSC_reqBotMscReset()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#gaa586eaec6263219ab634d012f7bcb5b7">USB_abortAllTransaction()</a>.</p>

</div>
</div>
<a class="anchor" id="ga326ecd2cba981840f9466939ac4f9a0e"></a><!-- doxytag: member="csl_usb.h::USB_bytesRemaining" ref="ga326ecd2cba981840f9466939ac4f9a0e" args="(pUsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#gab3da07d7e14ff698e33affd67b90e462">CSL_UsbByteCount</a> USB_bytesRemaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_bytesRemaining</b> </p>
<p><b>Description</b> <br/>
 This API returns number of bytes waiting to be transferred from the previously posted data transfer request.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbByteCount <br/>
 Number of bytes waiting to be transferred</p>
<p><b> Pre Condition </b> <br/>
 Post transaction API should be called successfully</p>
<p><b> Post Condition </b> <br/>
 1. Returns the number of bytes waiting <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void      (*evtHandler)();
 			Uint16    dadaBuf[256];

 			pUsbEpHandle   hEp;
            CSL_Status     status;
            Uint16         byteCount;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);

			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			...
			...
			byteCount = USB_bytesRemaining(hEp ,&amp;status);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__CDC__FUNCTION.html#gadb0ab40c5f6cee7bac0046161d94764e">CDC_bulkInHandler()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gad1a67b00017df33b468e7271553ceda4">CDC_bulkOutHandler()</a>, and <a class="el" href="group__CSL__CDC__FUNCTION.html#gaf8aedd6007bcb2c6a47afa47ee78e2ac">CDC_putData()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f9eaf8c608967c23b7608093476a6ac"></a><!-- doxytag: member="csl_usbAux.h::USB_checkSpeed" ref="ga4f9eaf8c608967c23b7608093476a6ac" args="(pUsbContext pContext, CSL_UsbBusSpeed *pBusSpeed)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Bool USB_checkSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#ga6220edfa1c5d35fdc5ccd13caf6e2abe">CSL_UsbBusSpeed</a> *&#160;</td>
          <td class="paramname"><em>pBusSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_checkSpeed</b> </p>
<p><b>Description</b> <br/>
 This function checks the USB bus speed</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
 	        pBusSpeed     -   USB Bus speed variable pointer
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>TRUE - Bus speed is valid </li>
<li>FALSE - Bus speed is invalid</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Checks the USB bus speed</p>
<p><b>Modifies</b> <br/>
 Bus speed variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			Bool              busSpeedStat;
			CSL_UsbContext    gUsbContext;
			CSL_UsbBusSpeed   *pBusSpeed

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			busSpeedStat = USB_checkSpeed(&amp;gUsbContext, &amp;gUsbContext.busSpeed);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__ENUM.html#gga6220edfa1c5d35fdc5ccd13caf6e2abeac0844d04f362fbed1e21be67189bb4ba">CSL_USB_BS_FULL_SPEED</a>, and <a class="el" href="group__CSL__USB__ENUM.html#gga6220edfa1c5d35fdc5ccd13caf6e2abea40b666f703e973729f2f600a2be43f69">CSL_USB_BS_HIGH_SPEED</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__USB__FUNCTION.html#ga8301a46f09b84292bca5a68b1b8bc087">USB_init()</a>.</p>

</div>
</div>
<a class="anchor" id="ga41df2dbcad5ef0c2517641667661c50b"></a><!-- doxytag: member="csl_usb.h::USB_clearEndptStall" ref="ga41df2dbcad5ef0c2517641667661c50b" args="(pUsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_clearEndptStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_clearEndptStall</b> </p>
<p><b>Description</b> <br/>
 This function clears an end point stall</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj and USB_stallEndpt should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Clears an end point stall</p>
<p><b>Modifies</b> <br/>
 USB control registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
  			void      (*evtHandler)();

 			pUsbEpHandle   hEp;
            CSL_Status     status;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);

			....
			....
			status = USB_stallEndpt(hEp);
			....
			....
			status = USB_clearEndptStall(hEp);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga084a56a2be6f658e477bc19731f33cd4">CSL_USB_ENDPOINT_COUNT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbEpStatus.html#a52b4b4145359b2eb9d80791795c35ac0">CSL_UsbEpStatus::fInitialized</a>, <a class="el" href="structCSL__UsbEpStatus.html#ae46604885557d80bc41bef180d471463">CSL_UsbEpStatus::fStalled</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga7d841894e9980d9fc1f743ed7b96f94a">AC_reqClearFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga1f96d6076d74de98e36849e51c860cc1">CDC_reqClearFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf05a6bcb3369eb0bb7370ace7c58f55b">MSC_reqClearFeature()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="gafddd09a5cff47ba64c04df2e55a80bff"></a><!-- doxytag: member="csl_usbAux.h::USB_confDmaRx" ref="gafddd09a5cff47ba64c04df2e55a80bff" args="(CSL_UsbHostPktDescr *hpdrx, Uint32 packetsize, Uint16 *pRxBuffer)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_confDmaRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *&#160;</td>
          <td class="paramname"><em>hpdrx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>packetsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pRxBuffer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_confDmaRx</b> </p>
<p><b>Description</b> <br/>
 Configures Dma for Data receive</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hpdrx         - Dma host packet descriptor pointer
 	        packetsize    - Size of the packet to receive (In Bytes)
 	        pRxBuffer     - Receive Data Buffer pointer
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initDma and USB_initQueueManager should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Receives the data from an end point</p>
<p><b>Modifies</b> <br/>
 USB Dma registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdrx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
			....
			....
			USB_confDmaRx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbHostPktDescr.html#a86ae9baab7f0074737c728a822c131dc">CSL_UsbHostPktDescr::Buffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acd4c5a89efb19d77b4a366ff05651af7">CSL_UsbHostPktDescr::Buffer0InfoWord1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d4591887663511ae649f58598324d55">CSL_USB_16BIT_REG_MASK</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acdcd4eb3f577c77ca493352e8740dc11">CSL_UsbHostPktDescr::LinkingWord</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a02678515e20358f23e7dd169901fb3d5">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a587f35c62327b3606eb432aee8c84728">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord1</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a4ad1fc4d926f3c2f470ca66086af932c">CSL_UsbHostPktDescr::PacketInfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#ade7ceeaec2d9c689f8f4bd69584611bd">CSL_UsbHostPktDescr::PacketInfoWord1</a>, and <a class="el" href="structCSL__UsbHostPktDescr.html#abc1c0b21280b4713f748a83082bc26e0">CSL_UsbHostPktDescr::PacketInfoWord2</a>.</p>

</div>
</div>
<a class="anchor" id="gae6cebacc623d4ec4f8f9a8fcc0636d54"></a><!-- doxytag: member="csl_usbAux.h::USB_confDmaTx" ref="gae6cebacc623d4ec4f8f9a8fcc0636d54" args="(CSL_UsbHostPktDescr *hpdtx, Uint32 packetsize, Uint16 *pTxBuffer, Bool swapWords)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_confDmaTx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *&#160;</td>
          <td class="paramname"><em>hpdtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>packetsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pTxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>swapWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_confDmaTx</b> </p>
<p><b>Description</b> <br/>
 Configures Dma for Data USB data transfer. For C5505 PG1.4 and earlier versions of the DSP, word swap is required for the data buffer before transferring the data. Parameter 'swapWords' provides facility to request for the word swap for the data buffer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hpdtx         - Dma host packet descriptor pointer
 	        packetsize    - Size of the packet to transmit (In Bytes)
 	        pTxBuffer     - Data Buffer pointer
			swapWords     - Flag to request for word swap
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initDma and USB_initQueueManager should be called successfully</p>
<p><b> Post Condition </b> <br/>
 transmits data to an end point</p>
<p><b>Modifies</b> <br/>
 USB Dma registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdtx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
			....
			....
			USB_confDmaTx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbHostPktDescr.html#a86ae9baab7f0074737c728a822c131dc">CSL_UsbHostPktDescr::Buffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acd4c5a89efb19d77b4a366ff05651af7">CSL_UsbHostPktDescr::Buffer0InfoWord1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d4591887663511ae649f58598324d55">CSL_USB_16BIT_REG_MASK</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#acdcd4eb3f577c77ca493352e8740dc11">CSL_UsbHostPktDescr::LinkingWord</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a02678515e20358f23e7dd169901fb3d5">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a587f35c62327b3606eb432aee8c84728">CSL_UsbHostPktDescr::OriginalBuffer0InfoWord1</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#a4ad1fc4d926f3c2f470ca66086af932c">CSL_UsbHostPktDescr::PacketInfoWord0</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#ade7ceeaec2d9c689f8f4bd69584611bd">CSL_UsbHostPktDescr::PacketInfoWord1</a>, <a class="el" href="structCSL__UsbHostPktDescr.html#abc1c0b21280b4713f748a83082bc26e0">CSL_UsbHostPktDescr::PacketInfoWord2</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#gaf81115692729a4f51bdd61e391bde2f7">USB_swapWords()</a>.</p>

</div>
</div>
<a class="anchor" id="ga99e256983f24a55e5ed37988b2414fb8"></a><!-- doxytag: member="csl_usb.h::USB_connectDev" ref="ga99e256983f24a55e5ed37988b2414fb8" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_connectDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_connectDev</b> </p>
<p><b>Description</b> <br/>
 This function connects the USB module to upstream port</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init function should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Connects the USB module</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            ....
            ....
            status = USB_connectDev(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga8f6caef50163af155f3c66e4a43420d6">AC_Open()</a>, <a class="el" href="csl__cdc_8c.html#a5f2b966400936ceb8448f50153c25845">CDC_Setup()</a>, and <a class="el" href="csl__msc_8c.html#a1497d92910a56f59560bf798ebb22372">MSC_Setup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2faee3616d8afc44cd0f3ee05f095f3c"></a><!-- doxytag: member="csl_usb.h::USB_coreEventProcessEp0" ref="ga2faee3616d8afc44cd0f3ee05f095f3c" args="(pUsbContext pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_coreEventProcessEp0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p><p>deviceDescPtr = (Uint16 *)deviceDesc;</p>
<p>cfgDescPtr = cfgDesc;</p>
<p>cfgDescPtr = cfgDesc;</p>
<p>cfgDescPtr = cfgDescFS;</p>
<p>cfgDescPtr = cfgDescFS;</p>
<p>strDescPtr = (Uint16 *)strDesc[0];</p>
<p>strDescPtr = (Uint16 *)strDesc[1];</p>
<p>strDescPtr = (Uint16 *)strDesc[2];</p>
<p>strDescPtr = (Uint16 *)strDesc[3];</p>
<p>deviceQualDescPtr = (Uint16 *)deviceQualDesc; </p>
</p>

<p>References <a class="el" href="structCSL__UsbSetupStruct.html#a78d44b3f43dbe57fe6e94c4c8014cbf3">CSL_UsbSetupStruct::bmRequestType</a>, <a class="el" href="structCSL__UsbSetupStruct.html#a850a2c66b0635a480baef52552a11099">CSL_UsbSetupStruct::bRequest</a>, <a class="el" href="structCSL__UsbContext.html#a037505d0bc604ad1bd5f0a639ced87d2">CSL_UsbContext::cfgDescFSPtr</a>, <a class="el" href="structCSL__UsbContext.html#a4919b018cfcf6e10621743360d95e889">CSL_UsbContext::cfgDescPtr</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga8b73d25d23446a05b4a17d657dbce8ab">CSL_USB_CLEAR_FEATURE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga72e84e4dda1fe78efab11926f6413326">CSL_USB_CONFIGURATION_DESCRIPTOR_TYPE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga562ecd768fe0a8835ca02e4900c55ce8">CSL_USB_DEVICE_DESCRIPTOR_TYPE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d19995a65e80b690d3d88dc665d7342">CSL_USB_DEVICE_QUAL_DESCRIPTOR_TYPE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga27953368972bacf018d289d44dc0198a">CSL_USB_FEATURE_ENDPOINT_STALL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga53ba9c525cb99ee2fef80c60786a69ab">CSL_USB_FEATURE_REMOTE_WAKEUP</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga9a3499fa4a6561730466c419e83ebe37">CSL_USB_GET_CONFIGURATION</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga6d12345471b594fec241e6ceeacdb055">CSL_USB_GET_DESCRIPTOR</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga75cd910e2af9dcc3cbe128171b428d26">CSL_USB_GET_INTERFACE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gacd0eda534ce1285fb3dda1d8fbe45dda">CSL_USB_GET_STATUS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga3b57c0b9ab404ea77f1ce71b57d81d9f">CSL_USB_IN_TRANSFER</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga665066a7eec07dd00b67ee02535d2e4f">CSL_USB_IOFLAG_CAT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gad3c23824bea6fec6a3b2ca672a576fef">CSL_USB_IOFLAG_LNK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga7bd2d646e37049bcdf340f27ca927e29">CSL_USB_IOFLAG_NONE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga8874c47ae40bc99a01424c1577538a25">CSL_USB_IOFLAG_NOSHORT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga0f950a82a8563d0c637cad4dd5e32743">CSL_USB_OTHERSPEED_CFG_DESCRIPTOR_TYPE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga254f8141ab8f26509d031277f0a568ef">CSL_USB_REQUEST_TYPE_DEVICE_STATUS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae7337f76fe3ca2263dfab65f68a54136">CSL_USB_SET_ADDRESS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gacadd27026e52cf3d2e39518fadfc37a0">CSL_USB_SET_CONFIGURATION</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gafdccc91fa2e89d97af53518c125d4d0b">CSL_USB_SET_FEATURE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga6614f709d5c8ae6959c9b1e60725f63a">CSL_USB_SET_INTERFACE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga53272d9c1da4ab92945aea678534a50e">CSL_USB_STRING_DESCRIPTOR_TYPE</a>, <a class="el" href="structCSL__UsbContext.html#ae3da201852e52d2c107be938a890eb74">CSL_UsbContext::ctrlInEpObj</a>, <a class="el" href="structCSL__UsbContext.html#acfee6e2afa9bee063464ab3b48d813f8">CSL_UsbContext::ctrlOutEpObj</a>, <a class="el" href="structCSL__UsbContext.html#a997dbc157cad2e89a21f4efb158be8cd">CSL_UsbContext::devAddr</a>, <a class="el" href="structCSL__UsbContext.html#a58d8a06b0c4805d6b883b4c94fbf0e27">CSL_UsbContext::deviceDescPtr</a>, <a class="el" href="structCSL__UsbContext.html#a35b012776923cb8913bfd03872cf7b72">CSL_UsbContext::deviceQualDescPtr</a>, <a class="el" href="structCSL__UsbContext.html#aed27684c2e235806c7737de42b8c7a78">CSL_UsbContext::hEpObjArray</a>, <a class="el" href="structCSL__UsbContext.html#aa8c21969a7ccfa3b6dc6ea6fa20b5d99">CSL_UsbContext::strDescPtr</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga41df2dbcad5ef0c2517641667661c50b">USB_clearEndptStall()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#gaf45935ea5e664abdc199e230db5cab5a">USB_epNumToHandle()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga4d61cd37fe4bd85380c09ec5838226c9">USB_getEndptStall()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#gaede526f4445bcac9971b56772e6916af">USB_getRemoteWakeupStat()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#gaf93dedf9cb26d01cd9175311587739aa">USB_getSetupPacket()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#gab8433a78959992028990dfb54b6f2489">USB_postTransaction()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga49c4ae738506de911efa58655cac46fc">USB_setConfiguration()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga42bd3cd663ef1cf0adba13ef80005885">USB_setDevAddr()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga40bfe702ae4e80d307dee7c6bef7af52">USB_setRemoteWakeup()</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga4367c71973487a2e9aa4f96b072f566a">USB_stallEndpt()</a>, <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>, <a class="el" href="structCSL__UsbContext.html#a90843e10499d10c6337964e8b47a849c">CSL_UsbContext::usbSetup</a>, <a class="el" href="structCSL__UsbSetupStruct.html#a3dae40396cdd9c4d62e7e1a017d94774">CSL_UsbSetupStruct::wIndex</a>, <a class="el" href="structCSL__UsbSetupStruct.html#a99f4f2c530e96b3b48fcfe75d63f3d72">CSL_UsbSetupStruct::wLength</a>, and <a class="el" href="structCSL__UsbSetupStruct.html#a20b94e0080d670cfd371b622838f24a7">CSL_UsbSetupStruct::wValue</a>.</p>

</div>
</div>
<a class="anchor" id="gac545ae84457dd2de1c56a7767a0fc2f0"></a><!-- doxytag: member="csl_usb.h::USB_disconnectDev" ref="gac545ae84457dd2de1c56a7767a0fc2f0" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_disconnectDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_disconnectDev</b> </p>
<p><b>Description</b> <br/>
 This function disconnects the USB module from the upstream port</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_connectDev should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Disconnects the USB module.</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			CSL_Status    status;

            status = USB_connectDev(CSL_USB0);
            ....
            ....
            status = USB_disconnectDev(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga79c4aedbceeb93f3e1623086a7d60116">AC_Close()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gaa465e845f107aecd014cf3f4055ec0ca">CDC_Close()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga0ff3428f21435535b0f5e2a702cc7098">MSC_Close()</a>.</p>

</div>
</div>
<a class="anchor" id="ga060b37017cf03824b93f431b550c8594"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaPopQue" ref="ga060b37017cf03824b93f431b550c8594" args="(Uint16 queueNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaPopQue </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>queueNum</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaPopQue</b> </p>
<p><b>Description</b> <br/>
 Function to popup the DMA queue. DMA descriptors will be removed from the queue.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        queueNum   - Queue number
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Popup the queue</p>
<p><b>Modifies</b> <br/>
 USB Queue manager registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">

			USB_dmaPopQue(24);
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="ga0ce6eaf5d8091633557b37df2bfae19a"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaRxStart" ref="ga0ce6eaf5d8091633557b37df2bfae19a" args="(DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaRxStart </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaRxStart</b> </p>
<p><b>Description</b> <br/>
 Starts Dma Receive</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 			dwEndpoint    - Endpoint number that is configured for Rx
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_confDmaRx should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts Dma data receive</p>
<p><b>Modifies</b> <br/>
 Data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdrx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
			....
			....
			USB_confDmaRx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaRxStart();
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__USB__FUNCTION.html#ga0fc2062e6251f1b011e3aa3f0c3bf029">USB_handleRx()</a>.</p>

</div>
</div>
<a class="anchor" id="ga20e4e8227fc3b0678345d88b40ff4bf0"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaRxStop" ref="ga20e4e8227fc3b0678345d88b40ff4bf0" args="(DWORD dwEndpoint, Uint16 *pRxBuffer, Uint32 packetsize, Bool swapWords)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaRxStop </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>pRxBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>packetsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>swapWords</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaRxStop</b> </p>
<p><b>Description</b> <br/>
 Stops Dma data Receive operation. For C5505 PG1.4 and earlier versions of the DSP, wordswap is required for the data buffer after completing the data reception. Parameter 'swapWords' provides facility to request for the word swap for the data buffer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
			dwEndpoint   - Endpoint number that is configured for Rx
 			pRxBuffer    -   DMA Receive data buffer
			packetsize   -   Size of the data received (In Bytes)
			swapWords    -   Flag to swap the words in the Rx buffer
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_dmaRxStart should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts Dma data receive</p>
<p><b>Modifies</b> <br/>
 USB Registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdrx;

			USB_confDmaRx(&amp;hpdrx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaRxStart();
			...
			...
			USB_dmaRxStop();
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__FUNCTION.html#gaf81115692729a4f51bdd61e391bde2f7">USB_swapWords()</a>.</p>

</div>
</div>
<a class="anchor" id="ga114e2c5f9ce4007fb69ce865dd9d2a36"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaTxStart" ref="ga114e2c5f9ce4007fb69ce865dd9d2a36" args="(DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaTxStart </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaTxStart</b> </p>
<p><b>Description</b> <br/>
 Starts Dma data transmit. DMA should be configure for the data transmit operation before calling this function. Data will be transmitted by the DMA as per the configured values.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 			dwEndpoint    - Endpoint number that is configured for Tx
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_confDmaTx should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts Dma data transfer</p>
<p><b>Modifies</b> <br/>
 USB FIFO registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdtx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdtx);
			....
			....
			USB_confDmaTx(&amp;hpdtx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaTxStart();
     </pre></div><p> ============================================================================ </p>

<p>Referenced by <a class="el" href="group__CSL__USB__FUNCTION.html#ga955117b9b701aa36f76cb14f62dd8b94">USB_handleTx()</a>.</p>

</div>
</div>
<a class="anchor" id="ga3569b5b61f6d08666713987ccf3504d9"></a><!-- doxytag: member="csl_usbAux.h::USB_dmaTxStop" ref="ga3569b5b61f6d08666713987ccf3504d9" args="(DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_dmaTxStop </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_dmaTxStop</b> </p>
<p><b>Description</b> <br/>
 Stops Dma data transmit.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 			dwEndpoint    - Endpoint number that is configured for Tx
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_dmaTxStart should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Stops Dma data receive</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			#define CSL_USB_DATA_SIZE    (256)
			Uint16    usbDataBuf[CSL_USB_DATA_SIZE];

			CSL_UsbHostPacketDescriptor    hpdtx;

			USB_confDmaTx(&amp;hpdtx, CSL_USB_DATA_SIZE, usbDataBuf);
			....
			....
			USB_dmaTxStart();
			...
			...
			USB_dmaTxStop();
     </pre></div><p> ============================================================================ </p>

</div>
</div>
<a class="anchor" id="gaf45935ea5e664abdc199e230db5cab5a"></a><!-- doxytag: member="csl_usb.h::USB_epNumToHandle" ref="gaf45935ea5e664abdc199e230db5cab5a" args="(CSL_UsbDevNum devNum, Uint16 endpt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a> USB_epNumToHandle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>endpt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_epNumToHandle</b> </p>
<p><b>Description</b> <br/>
 This function returns handle to an end point</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
            endPt         16-bit endpoint number as specified
 						  in the USB specification.
 						  0x00 -&gt; Endpt 0 Out.
 						  0x01 -&gt; Endpt 1 Out.
          				  0x80 -&gt; Endpt 0 In.
          				  0x81 -&gt; Endpt 1 In.
     </pre></div><p><b> Return Value </b> pUsbEpHandle <br/>
 Handle to the endpoint object if a valid endpoint object exists, else NULL object.</p>
<p><b> Pre Condition </b> <br/>
 USB_init function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 returns End point handle</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig    usbConfig;
            CSL_Status       status;
            pUsbEpHandle     hEp;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            .....
            hEp = USB_epNumToHandle(CSL_USB0, CSL_USB_IN_TRANSFER);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga084a56a2be6f658e477bc19731f33cd4">CSL_USB_ENDPOINT_COUNT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga29f63791a4ef0350bfe4993de81b1b35">CSL_USB_EP1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga553fc33bd0be32e335c795e73bbf8305">CSL_USB_EP3</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga33ece104d6445d6638217841eee066e5">CSL_USB_EP4</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a5d4ef74a48e7208821852d3919e4ed44">CSL_USB_IN_EP1</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a23167ee53dad55703cb68168e71ab6be">CSL_USB_IN_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a5120efe5b9675a2c190f73a40e68299f">CSL_USB_IN_EP3</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a3dd68ea171f7faedba9486e74f7f5060">CSL_USB_IN_EP4</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga3b57c0b9ab404ea77f1ce71b57d81d9f">CSL_USB_IN_TRANSFER</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401adfb1841c8e014ef2733a3559c83634f9">CSL_USB_OUT_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a106b0af97f87ee4a647af42b58861373">CSL_USB_OUT_EP1</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a99016b945a91fadf9a35db4efbd0ba3d">CSL_USB_OUT_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401afd66bd85fbe815aea2b1b62e39f94fb9">CSL_USB_OUT_EP3</a>, and <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a7733c747ccc18a1041c2c25b100dc9b5">CSL_USB_OUT_EP4</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga7d841894e9980d9fc1f743ed7b96f94a">AC_reqClearFeature()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gab27a06fee51ae94986d93e8fe386a46b">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga9bdac279f9b11af85f6625fdda352bfd">AC_reqSetFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gad1a67b00017df33b468e7271553ceda4">CDC_bulkOutHandler()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga1f96d6076d74de98e36849e51c860cc1">CDC_reqClearFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga420720b342969146f100476d0e1a05cc">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga1a4f5537fe2e2e1023d4d73f7e9700ec">CDC_reqSetFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf05a6bcb3369eb0bb7370ace7c58f55b">MSC_reqClearFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga68ba729d6c1cacff2b3cb6bd698e57ca">MSC_reqGetStatus()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gad384fa0f3748687df8ecb19afd4fb1b6">MSC_reqSetFeature()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="gae70a92d926f2bb1fe4398a3c3d5da1e1"></a><!-- doxytag: member="csl_usbAux.h::USB_flushFifo" ref="gae70a92d926f2bb1fe4398a3c3d5da1e1" args="(DWORD dwEndpoint, Bool fifoDirFlag)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_flushFifo </td>
          <td>(</td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>fifoDirFlag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_flushFifo</b> </p>
<p><b>Description</b> <br/>
 Function to flush the Tx and Rx FIFO of the USB</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        dwEndpoint  - End point to which FIFO flush is required
 	        fifoDirFlag - Flag to indicate the FIFO direction
 	                      1 - Tx FIFO, 0 - Rx FIFO
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Flushes Tx/Rx FIFO</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            //Flush Tx FIFO
			USB_flushFifo (CSL_USB_EP1, 1);

            //Flush Rx FIFO
			USB_flushFifo (CSL_USB_EP2, 0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>.</p>

</div>
</div>
<a class="anchor" id="gaa04d261f321e73e926364bea30e17243"></a><!-- doxytag: member="csl_usb.h::USB_getDataCountReadFromFifo" ref="gaa04d261f321e73e926364bea30e17243" args="(pUsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Uint16 USB_getDataCountReadFromFifo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getDataCountReadFromFifo</b> </p>
<p><b>Description</b> <br/>
 This function returns the most recent data count read from the FIFO. This function is supposed to use for the OUT end point. This function always return 0 for IN end point.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> Data count read from FIFO</p>
<p><b> Pre Condition </b> <br/>
 End point object should be initialized</p>
<p><b> Post Condition </b> <br/>
 Terminates data transfer in progress</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void  (*evtHandler)();

 			pUsbEpHandle     hEp;
            CSL_Status       status;
            Uint16           fifoDataCount;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);

            fifoDataCount = USB_getEvents(hEp);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpStatus.html#af3b25534a800990fe26ad9ed400b3e6e">CSL_UsbEpStatus::dataReadFromFifo</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, and <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__CDC__FUNCTION.html#gad1a67b00017df33b468e7271553ceda4">CDC_bulkOutHandler()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga8f75432972372fbe54c23661c7900fd1">MSC_verifyCBW()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4d61cd37fe4bd85380c09ec5838226c9"></a><!-- doxytag: member="csl_usb.h::USB_getEndptStall" ref="ga4d61cd37fe4bd85380c09ec5838226c9" args="(pUsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> USB_getEndptStall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getEndptStall</b> </p>
<p><b>Description</b> <br/>
 This function checks if an endpoint is stalled.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbBoolean </p>
<ul>
<li>CSL_USB_TRUE - If the end point is stalled. </li>
<li>CSL_USB_FALSE - If the end point is not stalled</li>
</ul>
<p><b> Pre Condition </b> <br/>
 Init End point API should be called successfully</p>
<p><b> Post Condition </b> <br/>
 1. Returns the end point stall status <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void      (*evtHandler)();

 			pUsbEpHandle      hEp;
            CSL_Status        status;
			CSL_UsbBoolean    epStall;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);
			...
			...
			epStall = USB_getEndptStall(hEp, &amp;status);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga084a56a2be6f658e477bc19731f33cd4">CSL_USB_ENDPOINT_COUNT</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbEpStatus.html#ae46604885557d80bc41bef180d471463">CSL_UsbEpStatus::fStalled</a>, and <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gab27a06fee51ae94986d93e8fe386a46b">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga420720b342969146f100476d0e1a05cc">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga68ba729d6c1cacff2b3cb6bd698e57ca">MSC_reqGetStatus()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga1177db34a8d022241109bc0dbfb2f0fb"></a><!-- doxytag: member="csl_usb.h::USB_getEvents" ref="ga1177db34a8d022241109bc0dbfb2f0fb" args="(pUsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a> USB_getEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getEvents</b> </p>
<p><b>Description</b> <br/>
 This API reads and clears all the pending USB_EVENTS associated with a particular USB endpoint.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbEventMask <br/>
 ORed combination of all the pending USB_EVENTS associated with a particular endpoint.</p>
<p><b> Pre Condition </b> <br/>
 End point object should be initialized</p>
<p><b> Post Condition </b> <br/>
 1. Clears and returns the end point events <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void  (*evtHandler)();

 			pUsbEpHandle     hEp;
            CSL_Status       status;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);
            USB_getEvents(hEp,
                          &amp;status);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gadd31b436250689602cc438e224ebb713">CSL_USB_EVENT_NONE</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="structCSL__UsbEpStatus.html#a647b16fc4fbedb633cec7c2bedb65131">CSL_UsbEpStatus::wUSBEvents</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gaa9e8be4f850baf2c6bae1292ac84edd4">AC_Ctrl()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gae01f53b7d63cc28cc0c08cd37c944143">AC_Iso()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaa15093092625dbf5cfa3d703a07733ab">MSC_Bulk()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#ga459f0629c19b630ec9e5dccd30707da0">MSC_Ctrl()</a>.</p>

</div>
</div>
<a class="anchor" id="ga641caf33fe52120dfe8473c3f66b76ad"></a><!-- doxytag: member="csl_usb.h::USB_getFrameNo" ref="ga641caf33fe52120dfe8473c3f66b76ad" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#gaf3bbf88b130333432b790039b6caf5a3">CSL_UsbFrameNum</a> USB_getFrameNo </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getFrameNo</b> </p>
<p><b>Description</b> <br/>
 This function reads current USB frame number</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
     </pre></div><p><b> Return Value </b> CSL_UsbFrameNum <br/>
 Current USB frame number</p>
<p><b> Pre Condition </b> <br/>
 USB init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns the frame number</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;
            Uint16             addr;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            ....
            ....
            status = USB_getFrameNo(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

</div>
</div>
<a class="anchor" id="ga810fdea6c6079a68858b9a46e3149b42"></a><!-- doxytag: member="csl_usb.h::USB_getMaxPower" ref="ga810fdea6c6079a68858b9a46e3149b42" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">WORD USB_getMaxPower </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getMaxPower</b> </p>
<p><b>Description</b> <br/>
 This function returns the maximum current drawn by the device. This is to inform the host about the device power requirement. This value is passed to the host through the configuration descriptor.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        None
     </pre></div><p><b> Return Value </b> Maximum current drawn by the device</p>
<p><b> Pre Condition </b> <br/>
 USB_init function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns the maximum current drawn by the device</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;
            Uint16             maxPower;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            .....
            maxPower = USB_getMaxPower(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gad8a24f8fd76b86cc9955c6c25e4fd49c">CSL_USB_INVALID_MAXPOWER</a>, and <a class="el" href="structCSL__UsbContext.html#ab54f413ec2073a7655674c1d3bb287c9">CSL_UsbContext::maxCurrent</a>.</p>

<p>Referenced by <a class="el" href="csl__msc_8c.html#a0fc3fc6e8063385f4dcd00e81cb2f80d">MSC_initCtrlDesc()</a>.</p>

</div>
</div>
<a class="anchor" id="gaede526f4445bcac9971b56772e6916af"></a><!-- doxytag: member="csl_usb.h::USB_getRemoteWakeupStat" ref="gaede526f4445bcac9971b56772e6916af" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> USB_getRemoteWakeupStat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getRemoteWakeupStat</b> </p>
<p><b>Description</b> <br/>
 This function returns the remote wake up feature status.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
     </pre></div><p><b> Return Value </b> CSL_UsbBoolean </p>
<ul>
<li>CSL_USB_TRUE - Remote wakeup feature is enabled. </li>
<li>CSL_USB_FALSE - Remote wakeup feature is disabled.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_setRemoteWakeup function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Returns remote wakeup status</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_Status        status;
            CSL_UsbBoolean    rmtWkpStat

            status = USB_setRemoteWakeup(CSL_USB0, CSL_USB_TRUE);

            if(status == CSL_SOK)
            {
		        rmtWkpStat = USB_getRemoteWakeupStat(CSL_USB0);
			}
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbContext.html#a97c50e33d1078291b636249b096075ef">CSL_UsbContext::remoteWkpStat</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gab27a06fee51ae94986d93e8fe386a46b">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga420720b342969146f100476d0e1a05cc">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga68ba729d6c1cacff2b3cb6bd698e57ca">MSC_reqGetStatus()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf93dedf9cb26d01cd9175311587739aa"></a><!-- doxytag: member="csl_usb.h::USB_getSetupPacket" ref="gaf93dedf9cb26d01cd9175311587739aa" args="(CSL_UsbDevNum devNum, CSL_UsbSetupStruct *usbSetup, Bool readFromFifo)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_getSetupPacket </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbSetupStruct.html">CSL_UsbSetupStruct</a> *&#160;</td>
          <td class="paramname"><em>usbSetup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>readFromFifo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_getSetupPacket</b> </p>
<p><b>Description</b> <br/>
 This function read the setup packet from the setup data buffer. This function can be used to read the setup packet from the FIFO or we can read the setup packet from the USB context structure. We can choose one of two options using readFromFifo parameter. If readFromFifo is TRUE setup packet is read from the FIFO. If readFromFifo is FALSE setup packet is read from the context structure. Setup packet should be read from FIFO when this function is called from interrupt handler(In this case read packet is stored in context structure) and setup packet should be read from USB context structure when this function is called from MSC layer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number
            usbSetup      Pointer to setup structure
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB Init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 USB setup structure is populated</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbSetupStruct    usbSetup;
            CSL_Status            status;
            CSL_UsbConfig         usbConfig

            status = USB_init(&amp;usbConfig);
            ....
            ....
            status = USB_getSetupPacket(CSL_USB0, &amp;usbSetup , TRUE);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbSetupStruct.html#a78d44b3f43dbe57fe6e94c4c8014cbf3">CSL_UsbSetupStruct::bmRequestType</a>, <a class="el" href="structCSL__UsbSetupStruct.html#a850a2c66b0635a480baef52552a11099">CSL_UsbSetupStruct::bRequest</a>, <a class="el" href="structCSL__UsbContext.html#a940c8780aaa5476969c4fdd86a4a26f5">CSL_UsbContext::cbOutEP0DataReceived</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1001f413ed82d56257c8dc7bec9a0730">CSL_USB_SETUP_PACKET_LEN</a>, <a class="el" href="structCSL__UsbSetupStruct.html#aade0aca2edf2c13071e94b329e74909c">CSL_UsbSetupStruct::newPacket</a>, <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>, <a class="el" href="structCSL__UsbContext.html#a90843e10499d10c6337964e8b47a849c">CSL_UsbContext::usbSetup</a>, <a class="el" href="structCSL__UsbSetupStruct.html#a3dae40396cdd9c4d62e7e1a017d94774">CSL_UsbSetupStruct::wIndex</a>, <a class="el" href="structCSL__UsbSetupStruct.html#a99f4f2c530e96b3b48fcfe75d63f3d72">CSL_UsbSetupStruct::wLength</a>, and <a class="el" href="structCSL__UsbSetupStruct.html#a20b94e0080d670cfd371b622838f24a7">CSL_UsbSetupStruct::wValue</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gaa9e8be4f850baf2c6bae1292ac84edd4">AC_Ctrl()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga7b222c2731e367428495fed788f61c39">CDC_eventHandler()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga459f0629c19b630ec9e5dccd30707da0">MSC_Ctrl()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga0fc2062e6251f1b011e3aa3f0c3bf029"></a><!-- doxytag: member="csl_usbAux.h::USB_handleRx" ref="ga0fc2062e6251f1b011e3aa3f0c3bf029" args="(pUsbContext pContext, DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_handleRx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleRx</b> </p>
<p><b>Description</b> <br/>
 Receives the data over the non-control end points This function can read the data in polled mode or using CPPI DMA. For the DMA mode operation opmode needs to be set to DMA using <a class="el" href="group__CSL__USB__FUNCTION.html#ga8301a46f09b84292bca5a68b1b8bc087">USB_init()</a> API and CPPI DMA needs to be configured for USB Rx operation using <a class="el" href="group__CSL__USB__FUNCTION.html#gafddd09a5cff47ba64c04df2e55a80bff">USB_confDmaRx()</a> API before calling this function.</p>
<p>USB DMA will be used when the data to be received is 64 or 512 bytes. CPU will be used to receive any other length of data.</p>
<p>Data to be recived will be read from the Rx FIFO one packet at a time. Legth of the packet will be decided based on the maximum packet size assigned to the Rx FIFO. In case of poll mode operation complete transfer callback function will be invoked after reading all the packets from the Rx FIFO. In case of DMA mode operation complete transfer callback will be invoked for each packet read. Complete transfer callback function is supposed to wait for DMA transfer completion.</p>
<p>Number of bytes read from FIFO in each transaction will be stored in 'pTransfer-&gt;prevTxferLen'. This value will be 64 or 512 when DMA mode is enabled and DMA is used for the data transfer. Other cases indicates that CPU mode is enabled or CPU is used for data transfer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
 	        dwEndpoint    -   End point number
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Reads data from an end point</p>
<p><b>Modifies</b> <br/>
 USB Data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_OUT_EP2,
									  CSL_USB_BULK,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_handleRx(&amp;gUsbContext, CSL_USB_EP2);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#ade5fc0a02836f9927de5fe486b9d17b2">CSL_UsbContext::fWaitingOnFlagB</a>, <a class="el" href="structCSL__UsbContext.html#a224b01404788a137bcb30877fc57f098">CSL_UsbContext::opMode</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbEpStatus.html#a9ed323d5ed5ba2ce5579ccaf4b4d6d3e">CSL_UsbEpStatus::pFifoAddr</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga0ce6eaf5d8091633557b37df2bfae19a">USB_dmaRxStart()</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

</div>
</div>
<a class="anchor" id="ga790f2cfc0abc1797a32edfb05dcb720a"></a><!-- doxytag: member="csl_usbAux.h::USB_handleRxIntr" ref="ga790f2cfc0abc1797a32edfb05dcb720a" args="(pUsbContext pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_handleRxIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleRxIntr</b> </p>
<p><b>Description</b> <br/>
 This function handles USb receive interrupts. This function is provided to be used with MSC module. For standalone MUSB operation this function is not required This function works only if EP2 configured for Rx</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Handles Rx interrupt</p>
<p><b>Modifies</b> <br/>
 USb registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_handleRxIntr(&amp;gUsbContext);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="structCSL__UsbContext.html#a3c64343858b027690cc8918c26464de3">CSL_UsbContext::fSetupPktCmd</a>, <a class="el" href="structCSL__UsbContext.html#ade5fc0a02836f9927de5fe486b9d17b2">CSL_UsbContext::fWaitingOnFlagB</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

</div>
</div>
<a class="anchor" id="ga955117b9b701aa36f76cb14f62dd8b94"></a><!-- doxytag: member="csl_usbAux.h::USB_handleTx" ref="ga955117b9b701aa36f76cb14f62dd8b94" args="(pUsbContext pContext, DWORD dwEndpoint)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_handleTx </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD&#160;</td>
          <td class="paramname"><em>dwEndpoint</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleTx</b> </p>
<p><b>Description</b> <br/>
 Transmits the data over the non-control end points. This function can transmit the data in polled mode or using CPPI DMA. For the DMA mode operation opmode needs to be set to DMA using <a class="el" href="group__CSL__USB__FUNCTION.html#ga8301a46f09b84292bca5a68b1b8bc087">USB_init()</a> API and CPPI DMA needs to be configured for USB Tx operation using <a class="el" href="group__CSL__USB__FUNCTION.html#gae6cebacc623d4ec4f8f9a8fcc0636d54">USB_confDmaTx()</a> API before calling this function.</p>
<p>USB DMA will be used when the data to be transferred is 64 or 512 bytes. CPU will be used to transfer any other length of data.</p>
<p>Data to be sent will be copied to the Tx FIFO one packet at a time. Legth of the packet will be decided based on the maximum packet size assigned to the Tx FIFO. In case of poll mode operation complete transfer callback function will be invoked after copying all the packets to the Tx FIFO. In case of DMA mode operation complete transfer callback will be invoked for each packet transferred. Complete transfer callback function is supposed to wait for DMA transfer completion.</p>
<p>Number of bytes written to FIFO in each transaction will be stored in 'pTransfer-&gt;prevTxferLen'. This value will be 64 or 512 when DMA mode is enabled and DMA is used for the data transfer. Other cases indicates that CPU mode is enabled or CPU is used for data transfer.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
 	        dwEndpoint    -   End point number
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Writes data to an end point</p>
<p><b>Modifies</b> <br/>
 USB FIFO registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP1,
									  CSL_USB_BULK,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_handleTx(&amp;gUsbContext, CSL_USB_EP1);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gaaff45fadbb316cd141ef34a431d2f30b">CSL_USB_IOFLAG_NOT</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbEpStatus.html#ae46604885557d80bc41bef180d471463">CSL_UsbEpStatus::fStalled</a>, <a class="el" href="structCSL__UsbContext.html#ae6eee30c7137ffb78edcb20b8b07dbf2">CSL_UsbContext::fWaitingOnFlagA</a>, <a class="el" href="structCSL__UsbTransfer.html#afc697a9b294d75bf57a7e0d6c03a18e8">CSL_UsbTransfer::ioFlags</a>, <a class="el" href="structCSL__UsbContext.html#a224b01404788a137bcb30877fc57f098">CSL_UsbContext::opMode</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbEpStatus.html#a9ed323d5ed5ba2ce5579ccaf4b4d6d3e">CSL_UsbEpStatus::pFifoAddr</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga114e2c5f9ce4007fb69ce865dd9d2a36">USB_dmaTxStart()</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

</div>
</div>
<a class="anchor" id="ga8ceaaae01b4ecf3ea8b1600b753567b4"></a><!-- doxytag: member="csl_usbAux.h::USB_handleTxIntr" ref="ga8ceaaae01b4ecf3ea8b1600b753567b4" args="(pUsbContext pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_handleTxIntr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_handleTxIntr</b> </p>
<p><b>Description</b> <br/>
 This function handles USB transmit interrupts.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Handles Tx interrupt</p>
<p><b>Modifies</b> <br/>
 USb registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_handleTxIntr(&amp;gUsbContext);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga29f63791a4ef0350bfe4993de81b1b35">CSL_USB_EP1</a>.</p>

</div>
</div>
<a class="anchor" id="ga8301a46f09b84292bca5a68b1b8bc087"></a><!-- doxytag: member="csl_usb.h::USB_init" ref="ga8301a46f09b84292bca5a68b1b8bc087" args="(CSL_UsbConfig *usbConfig)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbConfig.html">CSL_UsbConfig</a> *&#160;</td>
          <td class="paramname"><em>usbConfig</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_init</b> </p>
<p><b>Description</b> <br/>
 This function initializes USB module</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            usbConfig        USB Config structure
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Initializes the USB module</p>
<p><b>Modifies</b> <br/>
 USB context structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbConfig.html#aaadb07c556613c9a53a268a6ced47cfd">CSL_UsbConfig::appSuspendCallBack</a>, <a class="el" href="structCSL__UsbConfig.html#addcf4b83cf3d43c08ac534d74d764c1d">CSL_UsbConfig::appWakeupCallBack</a>, <a class="el" href="structCSL__UsbContext.html#a2058ced5aa45fa803d37eff7ac2881d1">CSL_UsbContext::busSpeed</a>, <a class="el" href="structCSL__UsbContext.html#a5300b2ef8aa1fc5568c0457ff9ebbf6a">CSL_UsbContext::cableState</a>, <a class="el" href="structCSL__UsbContext.html#a6065c6302f2f82fcb09d71b21a9ce9c8">CSL_UsbContext::cbOutEP0Buf</a>, <a class="el" href="structCSL__UsbContext.html#a940c8780aaa5476969c4fdd86a4a26f5">CSL_UsbContext::cbOutEP0DataReceived</a>, <a class="el" href="structCSL__UsbConfig.html#a677ebd6d1931ce4a8237be92ec8794ef">CSL_UsbConfig::completeTransferCallback</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga6220edfa1c5d35fdc5ccd13caf6e2abea40b666f703e973729f2f600a2be43f69">CSL_USB_BS_HIGH_SPEED</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga4c0e6371a5cfcaf139f61e12659fc1dc">CSL_USB_CLOCKSTOP_REG_DEF_VAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d23b7ff31818b958514c33aee22122c">CSL_USB_DELAY</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga06535792e2d597e119c1b562bd350847a43d5d6bfc4ddd9c9f937229b51484b45">CSL_USB_DEVICE_DETACH</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga084a56a2be6f658e477bc19731f33cd4">CSL_USB_ENDPOINT_COUNT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga3ea5752b72be519cccc704ed3369a31dafb54df283694dc092242c0093e4fbfda">CSL_USB_EP0_IDLE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gaf9d5fc912a04b5468540c138846ecc14">CSL_USB_EP0_PACKET_SIZE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga29f63791a4ef0350bfe4993de81b1b35">CSL_USB_EP1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga9b7638f44b72ccfc1d7dfebef4e4cd1f">CSL_USB_EP1_PACKET_SIZE_FS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gaf0d0de2378827590f79a62719da807ba">CSL_USB_EP1_PACKET_SIZE_HS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gaf5b3b267a2f5314680beb19585fcad28">CSL_USB_EP2_PACKET_SIZE_FS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gad62dd0e561c4c4df7daab0c43c5b81fa">CSL_USB_EP2_PACKET_SIZE_HS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga553fc33bd0be32e335c795e73bbf8305">CSL_USB_EP3</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga5ae8106dc977a54a918b5c46085a6004">CSL_USB_EP3_PACKET_SIZE_FS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga651e48033334c5ee8c4b1b0a675640ec">CSL_USB_EP3_PACKET_SIZE_HS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga33ece104d6445d6638217841eee066e5">CSL_USB_EP4</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga0e0bcfac98c481acdb720b467b763943">CSL_USB_EP4_PACKET_SIZE_FS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gacabb759f43fb8c7e26be6a71ab1495cf">CSL_USB_EP4_PACKET_SIZE_HS</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gadd31b436250689602cc438e224ebb713">CSL_USB_EVENT_NONE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga066c5d5b786f0230f7335b0a469e0847">CSL_USB_IN_EP_FIFO_START</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga3698457f67661a4d760ba57bb3ffd5aa">CSL_USB_PER_RESTCOUNT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga054dd8d4b3c647eb7f64c40191dd7475">CSL_USB_SYS_CTRL_REG_DEF_VAL</a>, <a class="el" href="structCSL__UsbConfig.html#a409222d144e2c473236058adf64bc56a">CSL_UsbConfig::devNum</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbContext.html#a5ddcf598a90a6f6249cf4c21c91933cb">CSL_UsbContext::ep0State</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#ac5163e07900bc1d7c152735b62ea8a57">CSL_UsbContext::fEP0BUFAvailable</a>, <a class="el" href="structCSL__UsbContext.html#aecddf8504c02ed56de4e366132efe5c3">CSL_UsbContext::fEP1InBUFAvailable</a>, <a class="el" href="structCSL__UsbContext.html#ae58f63d5dcb5725d654b1f47c8f9ae86">CSL_UsbContext::fInitialized</a>, <a class="el" href="structCSL__UsbEpStatus.html#a52b4b4145359b2eb9d80791795c35ac0">CSL_UsbEpStatus::fInitialized</a>, <a class="el" href="structCSL__UsbContext.html#a71f08f7693142ce7686b04e26f7540a3">CSL_UsbContext::fMUSBIsReady</a>, <a class="el" href="structCSL__UsbContext.html#a093a424e0722cec32c39bda0904007d2">CSL_UsbContext::fOutPhaseCmd</a>, <a class="el" href="structCSL__UsbEpStatus.html#a5e8f3dc93f27a066b8a895986a0ee25b">CSL_UsbEpStatus::fSelected</a>, <a class="el" href="structCSL__UsbContext.html#a7b8cc4290a7ac92082177a6f54cb8b3b">CSL_UsbContext::fSendHandshake</a>, <a class="el" href="structCSL__UsbContext.html#a3c64343858b027690cc8918c26464de3">CSL_UsbContext::fSetupPktCmd</a>, <a class="el" href="structCSL__UsbEpStatus.html#ae46604885557d80bc41bef180d471463">CSL_UsbEpStatus::fStalled</a>, <a class="el" href="structCSL__UsbContext.html#a9f88cdd19250056ce3a5edfddb09d96d">CSL_UsbContext::fWaitingOnEP0BUFAvail</a>, <a class="el" href="structCSL__UsbContext.html#afe95b5e66a55582808ad7b138a9c174c">CSL_UsbContext::fWaitingOnEP1InBUFAvail</a>, <a class="el" href="structCSL__UsbContext.html#ae6eee30c7137ffb78edcb20b8b07dbf2">CSL_UsbContext::fWaitingOnFlagA</a>, <a class="el" href="structCSL__UsbContext.html#ade5fc0a02836f9927de5fe486b9d17b2">CSL_UsbContext::fWaitingOnFlagB</a>, <a class="el" href="structCSL__UsbEpStatus.html#a03b8b47fcb961e70081585bced957f51">CSL_UsbEpStatus::hEventHandler</a>, <a class="el" href="structCSL__UsbConfig.html#a05e08b870df843c026ca716a1c6b60d8">CSL_UsbConfig::maxCurrent</a>, <a class="el" href="structCSL__UsbContext.html#ab54f413ec2073a7655674c1d3bb287c9">CSL_UsbContext::maxCurrent</a>, <a class="el" href="structCSL__UsbContext.html#a224b01404788a137bcb30877fc57f098">CSL_UsbContext::opMode</a>, <a class="el" href="structCSL__UsbConfig.html#a73ed17e272477e107c6da16143371a47">CSL_UsbConfig::opMode</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbEpStatus.html#a9ed323d5ed5ba2ce5579ccaf4b4d6d3e">CSL_UsbEpStatus::pFifoAddr</a>, <a class="el" href="structCSL__UsbContext.html#a7fdc14c26c14c0f3f878ce9ea7040d9f">CSL_UsbContext::pFIFOBaseAddress</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, <a class="el" href="structCSL__UsbContext.html#a97c50e33d1078291b636249b096075ef">CSL_UsbContext::remoteWkpStat</a>, <a class="el" href="structCSL__UsbConfig.html#aad1a59b62e5a1dd0421f0ede97d17894">CSL_UsbConfig::startTransferCallback</a>, <a class="el" href="structCSL__UsbContext.html#ad8b30685df68d72f51b911ab04c4a6c7">CSL_UsbContext::startTransferCallback</a>, <a class="el" href="structCSL__UsbContext.html#a1b57e78e2f836bd1a7751171468b3cc3">CSL_UsbContext::suspendCallBackFxn</a>, <a class="el" href="csl__usb_8c.html#a425fb4b3ab72fe4a572df4e36110e603">sysCtrlRegs</a>, <a class="el" href="group__CSL__USB__FUNCTION.html#ga4f9eaf8c608967c23b7608093476a6ac">USB_checkSpeed()</a>, <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>, <a class="el" href="structCSL__UsbContext.html#aec92669cb13ba4920fd4c30af612e58c">CSL_UsbContext::wakeupCallBackFxn</a>, and <a class="el" href="structCSL__UsbEpStatus.html#a647b16fc4fbedb633cec7c2bedb65131">CSL_UsbEpStatus::wUSBEvents</a>.</p>

</div>
</div>
<a class="anchor" id="ga617c12b1a886b29e550e006556a4f379"></a><!-- doxytag: member="csl_usbAux.h::USB_initDma" ref="ga617c12b1a886b29e550e006556a4f379" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_initDma </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_initDma</b> </p>
<p><b>Description</b> <br/>
 Initializes the Dma</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
			None
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Initializes USB Dma</p>
<p><b>Modifies</b> <br/>
 USB Dma registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbConfig      usbConfig;
			CSL_Status         status;

			usbConfig.maxCurrent = 50;
			.....
			.....
			status = USB_init(&amp;usbConfig);
			....
			....
			USB_initDma();
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gad1db60758e4b961a7ed8f43e645c78c9">CSL_USB_DMA_SCHED_CTRL1_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga771b07ed2fe6798bfaf536f0da1598dc">CSL_USB_ENTRYLSW_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga22355774f2a54915f2161723179ff840">CSL_USB_RXGCR1_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga16496a0530c41e0a1d909d5904b9f139">CSL_USB_RXGCR2_DEFVAL</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, and <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>.</p>

</div>
</div>
<a class="anchor" id="ga46e5b8803934b3b426c6905f1caf88fb"></a><!-- doxytag: member="csl_usb.h::USB_initEndptObj" ref="ga46e5b8803934b3b426c6905f1caf88fb" args="(CSL_UsbDevNum devNum, pUsbEpHandle hEp, CSL_UsbEpNum epNum, CSL_UsbXferType xferType, Uint16 maxPktSize, Uint16 evMask, CSL_USB_EVENT_ISR fxn)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_initEndptObj </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gadd63cd53e03e1d7e632a8cbe348e3401">CSL_UsbEpNum</a>&#160;</td>
          <td class="paramname"><em>epNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#ga66eb2483fddc8df328af8db4dca5cde0">CSL_UsbXferType</a>&#160;</td>
          <td class="paramname"><em>xferType</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>maxPktSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>evMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__SYMBOL.html#ga8419caa096a0b04548542413363c1341">CSL_USB_EVENT_ISR</a>&#160;</td>
          <td class="paramname"><em>fxn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_initEndptObj</b> </p>
<p><b>Description</b> <br/>
 This function initializes an endpoint object.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
            hEp           Handle to an endpoint object to be initialized.
            epNum         End point number
            xferType      Type of data transfer to be supported by the endpoint
            maxPktSize    Max data packet size supported by the endpoint.
            evMask        ORed combination of USB Interrupt Events to
 					  	  be broadcasted to the associated event handler
			fxn           Associated event handler routine.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init and USB_epNumToHandle functions should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Initializes an end point object</p>
<p><b>Modifies</b> <br/>
 End point object structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            void      (*evtHandler)();

            CSL_UsbConfig      usbConfig;
            CSL_Status         status;
            pUsbEpHandle       hEp;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            .....
            hEp = USB_epNumToHandle(CSL_USB0, CSL_USB_IN_TRANSFER);
            .....
            .....
            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gacd5db21c374abaddc791aaa1a3c2edf5">CSL_USB_FIFO_SIZE</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a5d4ef74a48e7208821852d3919e4ed44">CSL_USB_IN_EP1</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a23167ee53dad55703cb68168e71ab6be">CSL_USB_IN_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a5120efe5b9675a2c190f73a40e68299f">CSL_USB_IN_EP3</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a3dd68ea171f7faedba9486e74f7f5060">CSL_USB_IN_EP4</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a106b0af97f87ee4a647af42b58861373">CSL_USB_OUT_EP1</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a99016b945a91fadf9a35db4efbd0ba3d">CSL_USB_OUT_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401afd66bd85fbe815aea2b1b62e39f94fb9">CSL_USB_OUT_EP3</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a7733c747ccc18a1041c2c25b100dc9b5">CSL_USB_OUT_EP4</a>, <a class="el" href="structCSL__UsbEpStatus.html#af3b25534a800990fe26ad9ed400b3e6e">CSL_UsbEpStatus::dataReadFromFifo</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbEpObj.html#a11a36a9e79b311a1025a07b864c44215">CSL_UsbEpObj::eventMask</a>, <a class="el" href="structCSL__UsbEpStatus.html#a5e8f3dc93f27a066b8a895986a0ee25b">CSL_UsbEpStatus::fSelected</a>, <a class="el" href="structCSL__UsbEpObj.html#a62d871bcc5113a8e9f51ef6b23f66bbd">CSL_UsbEpObj::fxn</a>, <a class="el" href="structCSL__UsbEpStatus.html#a03b8b47fcb961e70081585bced957f51">CSL_UsbEpStatus::hEventHandler</a>, <a class="el" href="structCSL__UsbEpObj.html#a45a6691d26d2c2ce98f79bf94a4bdfae">CSL_UsbEpObj::maxPktSiz</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>, <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>, and <a class="el" href="structCSL__UsbEpObj.html#ac49486a6e87fbf0e93c30abc99e0774e">CSL_UsbEpObj::xferType</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga8f6caef50163af155f3c66e4a43420d6">AC_Open()</a>, <a class="el" href="csl__cdc_8c.html#a5f2b966400936ceb8448f50153c25845">CDC_Setup()</a>, and <a class="el" href="csl__msc_8c.html#a1497d92910a56f59560bf798ebb22372">MSC_Setup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga48dfe90c50e4929e45e5b6d700c6cf38"></a><!-- doxytag: member="csl_usb.h::USB_initPLL" ref="ga48dfe90c50e4929e45e5b6d700c6cf38" args="(void)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_initPLL </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_initPLL</b> </p>
<p><b>Description</b> <br/>
 Initializes PLL for USB operation. This function initializes the PLL to 100 MHz. For configuring PLL to any other frequency use PLL module.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
                   None
     </pre></div><p><b> Return Value </b> None <br/>
</p>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Initializes PLL</p>
<p><b>Modifies</b> <br/>
 PLL registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			USB_initPLL();
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga656d25f67e815335ecd683d220a36bef">CSL_USB_PLL_PLLCNTL1_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga28f498cbe1e23dbd0e57b591dc70f97c">CSL_USB_PLL_PLLCNTL2_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga082bed470c18990c15d2114fcb86ed03">CSL_USB_PLL_PLLINCNTL_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga1b40fec8e152e7ee146e78c7c5aa390f">CSL_USB_PLL_PLLOUTCNTL_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga99587abb8e09bebac34bc45b148bb9de">CSL_USB_PLL_TIMEOUT</a>, and <a class="el" href="csl__usb_8c.html#a425fb4b3ab72fe4a572df4e36110e603">sysCtrlRegs</a>.</p>

</div>
</div>
<a class="anchor" id="gaf1e70d7868d0da0abf71644d86863de0"></a><!-- doxytag: member="csl_usbAux.h::USB_initQueueManager" ref="gaf1e70d7868d0da0abf71644d86863de0" args="(CSL_UsbHostPktDescr *hpdtx, Uint32 *pLinkingRam)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_initQueueManager </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbHostPktDescr.html">CSL_UsbHostPktDescr</a> *&#160;</td>
          <td class="paramname"><em>hpdtx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32 *&#160;</td>
          <td class="paramname"><em>pLinkingRam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_initQueueManager</b> </p>
<p><b>Description</b> <br/>
 Initializes the Dma queue manager.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        hpdtx         - Dma host packet transmit descriptor pointer
			pLinkingRam   - Pointer to linking RAM data buffer
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initDma should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Initializes queue manager</p>
<p><b>Modifies</b> <br/>
 USB Queue manager registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbHostPacketDescriptor    hpdtx;

			USB_initDma();
			USB_initQueueManager(&amp;hpdrx);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga1d4591887663511ae649f58598324d55">CSL_USB_16BIT_REG_MASK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga85fecdcffe96ec468d83172a9316a2b5">CSL_USB_16BIT_REG_SHIFT</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae283f0564c96e38133010685aad3a70e">CSL_USB_LRAM0SIZE_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga9e195110e2f68b36ae203faf12a113ce">CSL_USB_QMEMRCTRL2_DEFVAL</a>, <a class="el" href="group__CSL__INTC__FUNCTION.html#ga12dfc0bac563a7d3bbbf72a56c2555b0">IRQ_globalDisable()</a>, and <a class="el" href="group__CSL__INTC__FUNCTION.html#gaf3a857c0a33806468646533f050d2ae0">IRQ_globalRestore()</a>.</p>

</div>
</div>
<a class="anchor" id="gaf55f2386166ce85e5f8d9361bcc3d1af"></a><!-- doxytag: member="csl_usb.h::USB_issueRemoteWakeup" ref="gaf55f2386166ce85e5f8d9361bcc3d1af" args="(CSL_UsbDevNum devNum, Bool resumeBitVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_issueRemoteWakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Bool&#160;</td>
          <td class="paramname"><em>resumeBitVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_issueRemoteWakeup</b> </p>
<p><b>Description</b> <br/>
 This function issues a remote wakeup signal to the host. NOTE: For remote wakeup protocol application program needs to call this function two times. In the first call resumeBitVal should be TRUE and in the second call resumeBitVal should be FALSE. Application should give a delay of 2 - 15 mSecs between the two calls. This is to avoid delays internal to the CSL module</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum           USB device number, Only USB0 is active currently.
            resumeBitVal     Value of the resume bit - TRUE or FALSE
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_setRemoteWakeup function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Issues a remote wake up signal.</p>
<p><b>Modifies</b> <br/>
 USB FADDR POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_Status    status;

            status = USB_setRemoteWakeup(CSL_USB0, CSL_USB_TRUE);

            if(status == CSL_SOK)
            {
		        status = USB_issueRemoteWakeup(CSL_USB0);
			}
     </pre></div><p> ============================================================================ </p>

<p><p>Set/Reset USB Resume bit </p>
</p>

<p>References <a class="el" href="structCSL__UsbContext.html#a97c50e33d1078291b636249b096075ef">CSL_UsbContext::remoteWkpStat</a>, and <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

</div>
</div>
<a class="anchor" id="ga541ad4e3334474fa15bc0e41eb66a854"></a><!-- doxytag: member="csl_usb.h::USB_isTransactionDone" ref="ga541ad4e3334474fa15bc0e41eb66a854" args="(pUsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a> USB_isTransactionDone </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_isTransactionDone</b> </p>
<p><b>Description</b> <br/>
 This function returns the status of the previously posted data transfer request.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbBoolean </p>
<ul>
<li>CSL_USB_TRUE - If the previously posted transfer is completed. </li>
<li>CSL_USB_FALSE - If the previously posted transfer is not completed.</li>
</ul>
<p><b> Pre Condition </b> <br/>
 Post transaction API should be called successfully</p>
<p><b> Post Condition </b> <br/>
 1. Returns the previous transaction status <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void      (*evtHandler)();
 			Uint16    dadaBuf[256];

 			pUsbEpHandle      hEp;
            CSL_Status        status;
            CSL_UsbBoolean    tscStatus;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);

			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
			...
			...
			tscStatus = USB_isTransactionDone(hEp ,&amp;status);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__CDC__FUNCTION.html#gadb0ab40c5f6cee7bac0046161d94764e">CDC_bulkInHandler()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gad1a67b00017df33b468e7271553ceda4">CDC_bulkOutHandler()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gaf8aedd6007bcb2c6a47afa47ee78e2ac">CDC_putData()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf60c95cbc0a950d1cd7bd64da25c5393">MSC_ExecuteRead()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga45c0497ae52ac8f7b0e463584f4b4fd1">MSC_ExecuteWrite()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaa8fe60cdc73972ffe7086c82ef153afe">MSC_HandleStateSendCSW()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga83a76450b952f0c3cc89cfff42d8f3ab">MSC_HandleStateSendData()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga6dd3562a0c66641cfdf6c6af28c50157">MSC_HandleStateSendStall()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gad147e64230628f238ae00b91f0c70d85">MSC_HandleStateWaitForCBW()</a>.</p>

</div>
</div>
<a class="anchor" id="ga738d92af63ce8891b61a6b6f899bad78"></a><!-- doxytag: member="csl_usbAux.h::USB_isValidDataInFifoOut" ref="ga738d92af63ce8891b61a6b6f899bad78" args="(pUsbEpStatus peps)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static Bool USB_isValidDataInFifoOut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpStatus.html">pUsbEpStatus</a>&#160;</td>
          <td class="paramname"><em>peps</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_isValidDataInFifoOut</b> </p>
<p><b>Description</b> <br/>
 This function checks validity of the data in the output FIFO</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        peps      -   End point status structure pointer
     </pre></div><p><b> Return Value </b> </p>
<ul>
<li>TRUE - FIFO out has valid data </li>
<li>FALSE - FIFO out no has valid data</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Checks the data in FIFO Out</p>
<p><b>Modifies</b> <br/>
 None</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			Bool              fifoStatus;
			CSL_UsbContext    gUsbContext;
			pUsbEpStatus      peps;

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			fifoStatus = USB_isValidDataInFifoOut(peps);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="structCSL__UsbEpStatus.html#af3b25534a800990fe26ad9ed400b3e6e">CSL_UsbEpStatus::dataReadFromFifo</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, and <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__CDC__FUNCTION.html#gad1a67b00017df33b468e7271553ceda4">CDC_bulkOutHandler()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4f33d1f861c059838d28ca10ce2fba5c"></a><!-- doxytag: member="csl_usb.h::USB_peekEvents" ref="ga4f33d1f861c059838d28ca10ce2fba5c" args="(pUsbEpHandle hEp, CSL_Status *status)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__CSL__USB__SYMBOL.html#ga87072d6bc79ccd6147812c988d653284">CSL_UsbEventMask</a> USB_peekEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CSL_Status *&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_peekEvents</b> </p>
<p><b>Description</b> <br/>
 This function read all the pending USB_EVENTS associated with a particular USB endpoint</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            status      Status of the function call
     </pre></div><p><b> Return Value </b> CSL_UsbEventMask <br/>
 ORed combination of all the pending USB_EVENTS associated with a particular endpoint. <br/>
</p>
<p><b> Pre Condition </b> <br/>
 End point object should be initialized</p>
<p><b> Post Condition </b> <br/>
 1. Returns the end point events <br/>
 2. Function call status is returned in status variable </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle</li>
</ul>
<p><b>Modifies</b> <br/>
 status variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void  (*evtHandler)();

 			CSL_UsbEpObj    epObj;
            CSL_Status      status;


            status = USB_initEndptObj(CSL_USB0,
                                      &amp;epObj,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);
            USB_peekEvents(&amp;epObj,
                           &amp;status);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gadd31b436250689602cc438e224ebb713">CSL_USB_EVENT_NONE</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="structCSL__UsbEpStatus.html#a647b16fc4fbedb633cec7c2bedb65131">CSL_UsbEpStatus::wUSBEvents</a>.</p>

</div>
</div>
<a class="anchor" id="gab8433a78959992028990dfb54b6f2489"></a><!-- doxytag: member="csl_usb.h::USB_postTransaction" ref="gab8433a78959992028990dfb54b6f2489" args="(pUsbEpHandle hEp, Uint16 byteCnt, void *data, CSL_UsbIoFlags flags)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_postTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>byteCnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__SYMBOL.html#ga451c5b10120bc3d838c3768571f5255c">CSL_UsbIoFlags</a>&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_postTransaction</b> </p>
<p><b>Description</b> <br/>
 This function transmits and receives USB data through an endpoint.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
            byteCnt     Total number of bytes in the buffer pointed by *data
            Data        Pointer to a data buffer
            flags       ORed combination of USB Data Transfer Flags
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init end point should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Starts the data transfer</p>
<p><b>Modifies</b> <br/>
 USB FIFO registers/data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void      (*evtHandler)();
 			Uint16    dadaBuf[256];

 			pUsbEpHandle    hEp;
            CSL_Status      status;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);

			status = USB_postTransaction(hEp, 256, dataBuf, CSL_USB_IOFLAG_NONE);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a6bb3b3321e6dbc55e0d3fdff138cf41e">CSL_USB_BULK</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a5d4ef74a48e7208821852d3919e4ed44">CSL_USB_IN_EP1</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a23167ee53dad55703cb68168e71ab6be">CSL_USB_IN_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a5120efe5b9675a2c190f73a40e68299f">CSL_USB_IN_EP3</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a3dd68ea171f7faedba9486e74f7f5060">CSL_USB_IN_EP4</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga3b57c0b9ab404ea77f1ce71b57d81d9f">CSL_USB_IN_TRANSFER</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga66eb2483fddc8df328af8db4dca5cde0a399fe6d4ec3e242e438c71a2c72f9786">CSL_USB_ISO</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401adfb1841c8e014ef2733a3559c83634f9">CSL_USB_OUT_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a106b0af97f87ee4a647af42b58861373">CSL_USB_OUT_EP1</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a99016b945a91fadf9a35db4efbd0ba3d">CSL_USB_OUT_EP2</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401afd66bd85fbe815aea2b1b62e39f94fb9">CSL_USB_OUT_EP3</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a7733c747ccc18a1041c2c25b100dc9b5">CSL_USB_OUT_EP4</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga7c724459bc6ead9129f4363b30fa8941">CSL_USB_OUT_TRANSFER</a>, <a class="el" href="structCSL__UsbTransfer.html#a6e5b3b949c48b2fd9ec440091e721712">CSL_UsbTransfer::dwEndpoint</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, <a class="el" href="structCSL__UsbTransfer.html#a7cdc2328e0e88e2472c8769f1b10e04a">CSL_UsbTransfer::dwFlags</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#ae58f63d5dcb5725d654b1f47c8f9ae86">CSL_UsbContext::fInitialized</a>, <a class="el" href="structCSL__UsbContext.html#a71f08f7693142ce7686b04e26f7540a3">CSL_UsbContext::fMUSBIsReady</a>, <a class="el" href="structCSL__UsbTransfer.html#afc697a9b294d75bf57a7e0d6c03a18e8">CSL_UsbTransfer::ioFlags</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>, <a class="el" href="structCSL__UsbContext.html#ad8b30685df68d72f51b911ab04c4a6c7">CSL_UsbContext::startTransferCallback</a>, <a class="el" href="structCSL__UsbEpStatus.html#aec17e0be81db9044aff64ec4f31dd32d">CSL_UsbEpStatus::xferType</a>, and <a class="el" href="structCSL__UsbEpObj.html#ac49486a6e87fbf0e93c30abc99e0774e">CSL_UsbEpObj::xferType</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gaa9e8be4f850baf2c6bae1292ac84edd4">AC_Ctrl()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gae01f53b7d63cc28cc0c08cd37c944143">AC_Iso()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gafc57df8802ebe8f343348c6db16e5dd1">AC_reqGetConfiguration()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gaf4039f9f73ef264de7b58ada1d206096">AC_reqGetCurrent()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga24877026b1ae88cbf741a7d3bea5bf99">AC_reqGetDescriptor()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga6a3210efab1ae1f7c94bdf50bcbfeedb">AC_reqGetInterface()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gac19d430506e5edbde1a191686d3838a0">AC_reqGetMaximum()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga43c1077c0f8a32d137c8401896b7cc2e">AC_reqGetMaxLUN()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga254da611dbf41320f26c02d709e99968">AC_reqGetMinimum()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gaee1d2c06dd91468ee673275f89717781">AC_reqGetResolution()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#gab27a06fee51ae94986d93e8fe386a46b">AC_reqGetStatus()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga48c317d7e5fc456c44a5a5ef81cc7860">AC_reqSetCurrent()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gadb0ab40c5f6cee7bac0046161d94764e">CDC_bulkInHandler()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gad1a67b00017df33b468e7271553ceda4">CDC_bulkOutHandler()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga7b222c2731e367428495fed788f61c39">CDC_eventHandler()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gaf8aedd6007bcb2c6a47afa47ee78e2ac">CDC_putData()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga692e30686113859cc70eb16fa6e3da0c">CDC_reqGetConfiguration()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga8178f574e21ca108dad32f10f26b28cf">CDC_reqGetInterface()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gac5c68c9d7b213530b849a969f70882f9">CDC_reqGetMaxLUN()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga420720b342969146f100476d0e1a05cc">CDC_reqGetStatus()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga459f0629c19b630ec9e5dccd30707da0">MSC_Ctrl()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf60c95cbc0a950d1cd7bd64da25c5393">MSC_ExecuteRead()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga45c0497ae52ac8f7b0e463584f4b4fd1">MSC_ExecuteWrite()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gabd34a0a4aeb1dc85c741520f91dfa11a">MSC_handleDataDirMisMatch()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gad2447ac2a44ada0bc743658cecb4d398">MSC_HandleInquiry()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gabe47df8e400eebbcb8700b243ace41e1">MSC_HandleModeSense10()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gab6d8e4488d60989e45e24df6b7b64683">MSC_HandleModeSense6()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga85287bd7183432ef23ea9916a349d7e5">MSC_HandlePreventAllowMediaRemoval()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga1f7ed066bf91bec5785e95466a76bd04">MSC_HandleReadCapacity()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga05b7f2c963c11f16edcb397945971dcb">MSC_HandleRequestSense()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga6d24b233ad05261666d36915fb93f143">MSC_HandleStartStopUnit()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga3bb637bcc9bbee4ed2ac72a64402931a">MSC_HandleStateReset()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaa8fe60cdc73972ffe7086c82ef153afe">MSC_HandleStateSendCSW()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga83a76450b952f0c3cc89cfff42d8f3ab">MSC_HandleStateSendData()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gac325a595a7163f040ae78084d4db2616">MSC_HandleStateSendingShortPkt()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga6dd3562a0c66641cfdf6c6af28c50157">MSC_HandleStateSendStall()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gad147e64230628f238ae00b91f0c70d85">MSC_HandleStateWaitForCBW()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaab9f5118d371664545a4997ac3dcf9d7">MSC_HandleTestUnitReady()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga367668bbaa620fcc20e29b683d7fc1de">MSC_HandleVerify10()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga4b12ad2d895d2f51d45c93e5253e1079">MSC_reqGetConfiguration()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gab2e125fe69ed7e3fe2180604f2a3ffba">MSC_reqGetDescriptor()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gabcdd09fdae29c9127cbd880807785f6c">MSC_reqGetInterface()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga125027445f36f5b48ad73286856f7a0a">MSC_reqGetMaxLUN()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga68ba729d6c1cacff2b3cb6bd698e57ca">MSC_reqGetStatus()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga7cfe2c7e9e15c5bb4281715c02ec867a">MSC_sendCswWithPhaseError()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga42111aab09b38aaa869715afb5b08072"></a><!-- doxytag: member="csl_usbAux.h::USB_processEP0In" ref="ga42111aab09b38aaa869715afb5b08072" args="(pUsbContext pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_processEP0In </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_processEP0In</b> </p>
<p><b>Description</b> <br/>
 Writes data to End point 0</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Writes data to end point0</p>
<p><b>Modifies</b> <br/>
 Ep0 FIFO registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_processEP0In(&amp;gUsbContext);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#gga3ea5752b72be519cccc704ed3369a31dafb54df283694dc092242c0093e4fbfda">CSL_USB_EP0_IDLE</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga743aabc061187885dfb62cae6e3923fb">CSL_USB_MAX_EP0_FIFO_LEN</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbContext.html#a5ddcf598a90a6f6249cf4c21c91933cb">CSL_UsbContext::ep0State</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#ac5163e07900bc1d7c152735b62ea8a57">CSL_UsbContext::fEP0BUFAvailable</a>, <a class="el" href="structCSL__UsbContext.html#a9f88cdd19250056ce3a5edfddb09d96d">CSL_UsbContext::fWaitingOnEP0BUFAvail</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, and <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="gab23a2e1141ef754e588258d3b79b482f"></a><!-- doxytag: member="csl_usbAux.h::USB_processEP0Out" ref="gab23a2e1141ef754e588258d3b79b482f" args="(pUsbContext pContext)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_processEP0Out </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_processEP0Out</b> </p>
<p><b>Description</b> <br/>
 Reads the data from End point 0</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Reads data from end point0</p>
<p><b>Modifies</b> <br/>
 Ep0 data buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_OUT_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_processEP0Out(&amp;gUsbContext);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbTransfer.html#a6d1543475e3b258c9627cfed78d5f535">CSL_UsbTransfer::cbBuffer</a>, <a class="el" href="structCSL__UsbContext.html#a6065c6302f2f82fcb09d71b21a9ce9c8">CSL_UsbContext::cbOutEP0Buf</a>, <a class="el" href="structCSL__UsbTransfer.html#af14b0f4d9487de67f84fd022d2c6e21d">CSL_UsbTransfer::cbTransferred</a>, <a class="el" href="structCSL__UsbContext.html#af8c3a99ab38b8f462ab15dc05b2b5abc">CSL_UsbContext::completeTransferCallback</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae2f228461fa9c4e40849cc426a9eb3e8">CSL_USB_MIN</a>, <a class="el" href="structCSL__UsbContext.html#a758c116a872fc4fb1dd36445a3c1de6d">CSL_UsbContext::dwOutEP0Buf</a>, <a class="el" href="structCSL__UsbTransfer.html#a7638409f249d027386c919e7d47e59de">CSL_UsbTransfer::fComplete</a>, <a class="el" href="structCSL__UsbContext.html#a093a424e0722cec32c39bda0904007d2">CSL_UsbContext::fOutPhaseCmd</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, <a class="el" href="structCSL__UsbTransfer.html#ac4c77b234b43d2ed991f488ac9e932b3">CSL_UsbTransfer::prevTxferLen</a>, <a class="el" href="structCSL__UsbEpStatus.html#a913838dc38f54696b2bd553c41c2d12c">CSL_UsbEpStatus::pTransfer</a>, and <a class="el" href="structCSL__UsbTransfer.html#a6060d16def7e740d3c8b0bbf18ec4fb1">CSL_UsbTransfer::pvBuffer</a>.</p>

</div>
</div>
<a class="anchor" id="ga3a745278253b3876c4e51a303d1df8a6"></a><!-- doxytag: member="csl_usbAux.h::USB_readEP0Buf" ref="ga3a745278253b3876c4e51a303d1df8a6" args="(pUsbContext pContext, DWORD *pBuf)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_readEP0Buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbContext.html">pUsbContext</a>&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DWORD *&#160;</td>
          <td class="paramname"><em>pBuf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_readEP0Buf</b> </p>
<p><b>Description</b> <br/>
 This function reads the End point0 buffer</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
 	        pBusSpeed     -   USB Bus speed variable pointer
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Reads Ep0 data</p>
<p><b>Modifies</b> <br/>
 Ep0 Buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;
			CSL_UsbBusSpeed   *pBusSpeed

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_readEP0Buf(&amp;gUsbContext, &amp;gUsbContext.dwOutEP0Buf);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbContext.html#a940c8780aaa5476969c4fdd86a4a26f5">CSL_UsbContext::cbOutEP0DataReceived</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga743aabc061187885dfb62cae6e3923fb">CSL_USB_MAX_EP0_FIFO_LEN</a>, and <a class="el" href="structCSL__UsbContext.html#a758c116a872fc4fb1dd36445a3c1de6d">CSL_UsbContext::dwOutEP0Buf</a>.</p>

</div>
</div>
<a class="anchor" id="gae4c0648f5992d00af0cd4332bdde9cfe"></a><!-- doxytag: member="csl_usb.h::USB_resetDev" ref="gae4c0648f5992d00af0cd4332bdde9cfe" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_resetDev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_resetDev</b> </p>
<p><b>Description</b> <br/>
 This function resets the USB device</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Resets the USB device</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            ....
            ....
            status = USB_resetDev(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga29f63791a4ef0350bfe4993de81b1b35">CSL_USB_EP1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga553fc33bd0be32e335c795e73bbf8305">CSL_USB_EP3</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga33ece104d6445d6638217841eee066e5">CSL_USB_EP4</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gafce0d8752f7dfe518cb5ac9d3a5fa034">CSL_USB_INTMSKSETR1_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga3f7385f0005511f9bd39719b09436432">CSL_USB_INTMSKSETR2_DEFVAL</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#gae6d0733555a609c0d64e8f8e2f2fe1e3">CSL_USB_INTRUSB_INTRUSBE_DEFVAL</a>, <a class="el" href="structCSL__UsbContext.html#a71f08f7693142ce7686b04e26f7540a3">CSL_UsbContext::fMUSBIsReady</a>, and <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

</div>
</div>
<a class="anchor" id="ga017f622aab04990632100eb52a86b9bb"></a><!-- doxytag: member="csl_usb.h::USB_selfwakeup" ref="ga017f622aab04990632100eb52a86b9bb" args="(CSL_UsbDevNum devNum, Uint32 wakeupDelay)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_selfwakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>wakeupDelay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_selfwakeup</b> </p>
<p><b>Description</b> <br/>
 This function issues a self wakeup signal on the bus. This function can be mapped to an external event like pressing a button on the EVM. After responding to that event through a call back, USB device send a wakeup signal on the bus. NOTE: Application needs to send a delay as a parameter to this function. According to USB wakeup specification an approximate delay of 10mSecs(Min 2 to Max 15 mSecs) is required to send a wakeup signal on the bus. This delay is introduced between setting the resume bit to '1' and restting it to '0'. Application needs to decide a delay such that it is maximum enough to satisfy USB wakeup protocol and minimum to satisfy the USB driver performance.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
            wakeupDelay   Delay between Resume bit set and reset
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init be called successfully and an external event should occur.</p>
<p><b> Post Condition </b> <br/>
 Send a wakeup signal on the bus.</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;
            Uint16             addr;
            Uint32             wakeupDelay;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            ....
            ....
            //This function call should be mapped to an external event
            wakeupDelay = 1000000;
            status = USB_selfwakeup(CSL_USB0, wakeupDelay);
     </pre></div><p> ============================================================================ </p>

<p><p>Set USB Resume bit</p>
<p>Reset the resume bit </p>
</p>

<p>References <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>, and <a class="el" href="structCSL__UsbContext.html#aec92669cb13ba4920fd4c30af612e58c">CSL_UsbContext::wakeupCallBackFxn</a>.</p>

</div>
</div>
<a class="anchor" id="ga49c4ae738506de911efa58655cac46fc"></a><!-- doxytag: member="csl_usbAux.h::USB_setConfiguration" ref="ga49c4ae738506de911efa58655cac46fc" args="(CSL_UsbDevNum devNum, Uint16 confVal)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static void USB_setConfiguration </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>confVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setConfiguration</b> </p>
<p><b>Description</b> <br/>
 This function sets the end point configuration This is provided to use with MSC module This function is not required for standalone MUSB testing</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        pContext      -   USB context structure pointer
 	        pBusSpeed     -   USB Bus speed variable pointer
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB_initEndptObj function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Checks the USB bus speed</p>
<p><b>Modifies</b> <br/>
 Bus speed variable</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			void  (*evtHandler)();

			pUsbEpHandle      hEp;
			CSL_Status        status;
			CSL_UsbContext    gUsbContext;
			CSL_UsbBusSpeed   *pBusSpeed

			status = USB_initEndptObj(CSL_USB0,
									  hEp,
									  CSL_USB_IN_EP0,
									  CSL_USB_CTRL,
									  0x40,
									  CSL_USB_EVENT_RESET,
									  evtHandler);
			....
			....
			status = USB_setConfiguration(CSL_USB0, 0x02);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga29f63791a4ef0350bfe4993de81b1b35">CSL_USB_EP1</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga64f171d9337f1707ec073d72c8ecd449">CSL_USB_EP2</a>, <a class="el" href="group__CSL__USB__SYMBOL.html#ga553fc33bd0be32e335c795e73bbf8305">CSL_USB_EP3</a>, and <a class="el" href="group__CSL__USB__SYMBOL.html#ga33ece104d6445d6638217841eee066e5">CSL_USB_EP4</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gaaefd0c376a48b72ab55244d09ab5d656">AC_reqSetConfiguration()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#gaab167ab2d489069117b13b681a828e45">CDC_reqSetConfiguration()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga610dfbbac85ceb7cbcc3ece15098a1a6">CDC_reqSetInterface()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gac82ef81d36f6dda66aba755df9f21675">MSC_reqSetConfiguration()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga193bbf9a04e32a4eb75bb1338c5fe75e">MSC_reqSetInterface()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga42bd3cd663ef1cf0adba13ef80005885"></a><!-- doxytag: member="csl_usb.h::USB_setDevAddr" ref="ga42bd3cd663ef1cf0adba13ef80005885" args="(CSL_UsbDevNum devNum, Uint16 addr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_setDevAddr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>addr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setDevAddr</b> </p>
<p><b>Description</b> <br/>
 This function sets the device Address to USB controller</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
            addr          Address to set
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB_init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Configures device address registers</p>
<p><b>Modifies</b> <br/>
 Device address registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;
            Uint16             addr;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            ....
            ....
            status = USB_setDevAddr(CSL_USB0, addr);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga7c7c86d2ef6c17a1756e9b47eea31abe">AC_reqSetAddress()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga138bb867034613b3b6c7be86db89e1df">CDC_reqSetAddress()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga3a16d5d0278789732fa21a3dbee22980">MSC_reqSetAddress()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga77da82b7f7cd6b40da44da48c6e0d09b"></a><!-- doxytag: member="csl_usb.h::USB_setFullSpeedMode" ref="ga77da82b7f7cd6b40da44da48c6e0d09b" args="(Uint16 ep0DataSize)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void USB_setFullSpeedMode </td>
          <td>(</td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>ep0DataSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setFullSpeedMode</b> </p>
<p><b>Description</b> <br/>
 This function is used to set the USB controller into full speed mode ep0DataSize is the size of the EP0 FIFO. This value should be within the range of values recommended by the USB specification.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
 	        None
     </pre></div><p><b> Return Value </b> None</p>
<p><b> Pre Condition </b> <br/>
 USB Init should be called successfully</p>
<p><b> Post Condition </b> <br/>
 USB will be set for full speed mode</p>
<p><b>Modifies</b> <br/>
 USB registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbSetupStruct    usbSetup;
            CSL_Status            status;
            CSL_UsbConfig         usbConfig

            status = USB_init(&amp;usbConfig);
            ....
            ....
            USB_setFullSpeedMode(0x20);

     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="structCSL__UsbEpStatus.html#a494f02bbd449b9d0160746e74d314d67">CSL_UsbEpStatus::dwPacketSizeAssigned</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__CDC__FUNCTION.html#gaa962abadf88e0558eb73e9af31ca8938">CDC_OpenFullspeed()</a>, and <a class="el" href="group__CSL__MSC__FUNCTION.html#gacdcc9297237397e4f373abfdccd879b6">MSC_OpenFullspeed()</a>.</p>

</div>
</div>
<a class="anchor" id="gaed27bb8e5240ac3c693aedf8f3016254"></a><!-- doxytag: member="csl_usb.h::USB_setParams" ref="gaed27bb8e5240ac3c693aedf8f3016254" args="(CSL_UsbDevNum devNum, pUsbEpHandle hEpObj[], Uint16 pSofTmrCnt)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_setParams </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEpObj</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint16&#160;</td>
          <td class="paramname"><em>pSofTmrCnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setParams</b> </p>
<p><b>Description</b> <br/>
 This function initializes the global end point handle array</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
            hEpObj        Pointer to a array of endpoint handle.
            pSofTmrCnt    8-bit counter value for the pre SOF timer.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 Initializes global end point handle array</p>
<p><b>Modifies</b> <br/>
 Global end point handle array</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
			CSL_UsbEpObj    hEpObjArray[CSL_USB_ENDPOINT_COUNT];
			CSL_Status      status;

			status = USB_setParams(CSL_USB0, &amp;hEpObjArray, 0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#ga084a56a2be6f658e477bc19731f33cd4">CSL_USB_ENDPOINT_COUNT</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gaa9e8be4f850baf2c6bae1292ac84edd4">AC_Ctrl()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga8f6caef50163af155f3c66e4a43420d6">AC_Open()</a>, <a class="el" href="csl__cdc_8c.html#a5f2b966400936ceb8448f50153c25845">CDC_Setup()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga459f0629c19b630ec9e5dccd30707da0">MSC_Ctrl()</a>, and <a class="el" href="csl__msc_8c.html#a1497d92910a56f59560bf798ebb22372">MSC_Setup()</a>.</p>

</div>
</div>
<a class="anchor" id="ga40bfe702ae4e80d307dee7c6bef7af52"></a><!-- doxytag: member="csl_usb.h::USB_setRemoteWakeup" ref="ga40bfe702ae4e80d307dee7c6bef7af52" args="(CSL_UsbDevNum devNum, CSL_UsbBoolean rmtWkpStat)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_setRemoteWakeup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#ga5d102397ad06d902df565f3a4ecc2a91">CSL_UsbBoolean</a>&#160;</td>
          <td class="paramname"><em>rmtWkpStat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_setRemoteWakeup</b> </p>
<p><b>Description</b> <br/>
 This function sets or clears Remote Wakeup Feature.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
            rmtWkpStat    Remote wake up status flag
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init function should be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Sets the remote wake up status</p>
<p><b>Modifies</b> <br/>
 Remote wakeup status variable in the USB global context structure</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            ....
            ....
            status = USB_setRemoteWakeup(CSL_USB0, CSL_USB_TRUE);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbContext.html#a97c50e33d1078291b636249b096075ef">CSL_UsbContext::remoteWkpStat</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#ga7d841894e9980d9fc1f743ed7b96f94a">AC_reqClearFeature()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga9bdac279f9b11af85f6625fdda352bfd">AC_reqSetFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga1f96d6076d74de98e36849e51c860cc1">CDC_reqClearFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga1a4f5537fe2e2e1023d4d73f7e9700ec">CDC_reqSetFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf05a6bcb3369eb0bb7370ace7c58f55b">MSC_reqClearFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gad384fa0f3748687df8ecb19afd4fb1b6">MSC_reqSetFeature()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga4367c71973487a2e9aa4f96b072f566a"></a><!-- doxytag: member="csl_usb.h::USB_stallEndpt" ref="ga4367c71973487a2e9aa4f96b072f566a" args="(pUsbEpHandle hEp)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_stallEndpt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structCSL__UsbEpObj.html">pUsbEpHandle</a>&#160;</td>
          <td class="paramname"><em>hEp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_stallEndpt</b> </p>
<p><b>Description</b> <br/>
 This function stalls an end point</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            hEp         Handle to an initialized endpoint object.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_BADHANDLE - Invalid end point handle </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 End point init function should be called successfully</p>
<p><b> Post Condition </b> <br/>
 Stalls an end point associated with the passed handle</p>
<p><b>Modifies</b> <br/>
 USB control registers</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
 			void      (*evtHandler)();

 			pUsbEpHandle   hEp;
            CSL_Status     status;

            status = USB_initEndptObj(CSL_USB0,
                                      hEp,
                                      CSL_USB_OUT_EP0,
                                      CSL_USB_CTRL,
                                      0x40,
                                      CSL_USB_EVENT_RESET,
                                      evtHandler);			...
			...
			status = USB_stallEndpt(hEp);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="group__CSL__USB__SYMBOL.html#gabc2c4e7c3bca3544b1318a7233d8f8af">CSL_USB_EP0</a>, <a class="el" href="group__CSL__USB__ENUM.html#ggadd63cd53e03e1d7e632a8cbe348e3401a97323645e1dcb733d9da5adde0b0c61e">CSL_USB_IN_EP0</a>, <a class="el" href="structCSL__UsbEpStatus.html#a0075dd5697663893796755a5bb1b4bf2">CSL_UsbEpStatus::dwEndpoint</a>, <a class="el" href="structCSL__UsbEpObj.html#ad4ce987df34a61eddda4fdf95c3beef1">CSL_UsbEpObj::epNum</a>, <a class="el" href="structCSL__UsbEpStatus.html#a52b4b4145359b2eb9d80791795c35ac0">CSL_UsbEpStatus::fInitialized</a>, <a class="el" href="structCSL__UsbEpStatus.html#ae46604885557d80bc41bef180d471463">CSL_UsbEpStatus::fStalled</a>, <a class="el" href="structCSL__UsbContext.html#a8939f65631caf1b6a7812dd48689f698">CSL_UsbContext::pEpStatus</a>, and <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

<p>Referenced by <a class="el" href="group__CSL__AC__FUNCTION.html#gaa9e8be4f850baf2c6bae1292ac84edd4">AC_Ctrl()</a>, <a class="el" href="group__CSL__AC__FUNCTION.html#ga9bdac279f9b11af85f6625fdda352bfd">AC_reqSetFeature()</a>, <a class="el" href="group__CSL__CDC__FUNCTION.html#ga1a4f5537fe2e2e1023d4d73f7e9700ec">CDC_reqSetFeature()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga459f0629c19b630ec9e5dccd30707da0">MSC_Ctrl()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaf60c95cbc0a950d1cd7bd64da25c5393">MSC_ExecuteRead()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gabd34a0a4aeb1dc85c741520f91dfa11a">MSC_handleDataDirMisMatch()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gabe47df8e400eebbcb8700b243ace41e1">MSC_HandleModeSense10()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gab6d8e4488d60989e45e24df6b7b64683">MSC_HandleModeSense6()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga85287bd7183432ef23ea9916a349d7e5">MSC_HandlePreventAllowMediaRemoval()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga6d24b233ad05261666d36915fb93f143">MSC_HandleStartStopUnit()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gac325a595a7163f040ae78084d4db2616">MSC_HandleStateSendingShortPkt()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gad147e64230628f238ae00b91f0c70d85">MSC_HandleStateWaitForCBW()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gaab9f5118d371664545a4997ac3dcf9d7">MSC_HandleTestUnitReady()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#ga367668bbaa620fcc20e29b683d7fc1de">MSC_HandleVerify10()</a>, <a class="el" href="group__CSL__MSC__FUNCTION.html#gad384fa0f3748687df8ecb19afd4fb1b6">MSC_reqSetFeature()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga2faee3616d8afc44cd0f3ee05f095f3c">USB_coreEventProcessEp0()</a>.</p>

</div>
</div>
<a class="anchor" id="ga2fa2188b3893dc1dc78c63f7b5181b91"></a><!-- doxytag: member="csl_usb.h::USB_suspendDevice" ref="ga2fa2188b3893dc1dc78c63f7b5181b91" args="(CSL_UsbDevNum devNum)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CSL_Status USB_suspendDevice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__CSL__USB__ENUM.html#gae24bafe3c8466da23b8da46424b3ff43">CSL_UsbDevNum</a>&#160;</td>
          <td class="paramname"><em>devNum</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>============================================================================ <br/>
<b>USB_suspendDevice</b> </p>
<p><b>Description</b> <br/>
 This function suspends the USB device. This function informs the application about the device suspend through a call back function.</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            devNum        USB device number, Only USB0 is active currently.
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Returned for success </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameter</li>
</ul>
<p><b> Pre Condition </b> <br/>
 USB init be called successfully.</p>
<p><b> Post Condition </b> <br/>
 Puts the USB device into suspend mode.</p>
<p><b>Modifies</b> <br/>
 USB FADDR_POWER register</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            CSL_UsbConfig      usbConfig;
            CSL_Status         status;
            Uint16             addr;

            usbConfig.maxCurrent = 50;
            .....
            .....
            status = USB_init(&amp;usbConfig);
            ....
            ....
            status = USB_suspendDevice(CSL_USB0);
     </pre></div><p> ============================================================================ </p>

<p>References <a class="el" href="structCSL__UsbContext.html#a1b57e78e2f836bd1a7751171468b3cc3">CSL_UsbContext::suspendCallBackFxn</a>, and <a class="el" href="group__CSL__CDC__DATASTRUCT.html#ga3a779f02649275a99b98db0eec619e5f">usbRegisters</a>.</p>

</div>
</div>
<a class="anchor" id="gaf81115692729a4f51bdd61e391bde2f7"></a><!-- doxytag: member="csl_usbAux.h::USB_swapWords" ref="gaf81115692729a4f51bdd61e391bde2f7" args="(Uint16 *dataBuffer, Uint32 dataLength)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">static CSL_Status USB_swapWords </td>
          <td>(</td>
          <td class="paramtype">Uint16 *&#160;</td>
          <td class="paramname"><em>dataBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Uint32&#160;</td>
          <td class="paramname"><em>dataLength</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td><code> [inline, static]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>=========================================================================== <br/>
<b>USB_swapWords</b> </p>
<p><b>Description</b> <br/>
 This function swaps words in a given buffer</p>
<p><b>Arguments</b> </p>
<div class="fragment"><pre class="fragment">
            dataBuffer    Pointer to the buffer which words needs to be swapped
            dataLength    Length of data to be word swapped (In words)
     </pre></div><p><b> Return Value </b> CSL_Status </p>
<ul>
<li>CSL_SOK - Reset successful </li>
<li>CSL_ESYS_INVPARAMS - Invalid parameters</li>
</ul>
<p><b> Pre Condition </b> <br/>
 None</p>
<p><b> Post Condition </b> <br/>
 None</p>
<p><b>Modifies</b> <br/>
 Order of data in the given buffer</p>
<p><b>Example</b> </p>
<div class="fragment"><pre class="fragment">
            #define USB_PACKET_SIZE (256)

            Uint16        usbBuf [USB_PACKET_SIZE];
            CSL_Status    status;

            status = USB_swapWords (usbBuf, USB_PACKET_SIZE);
     </pre></div><p> =========================================================================== </p>

<p>Referenced by <a class="el" href="group__CSL__USB__FUNCTION.html#gae6cebacc623d4ec4f8f9a8fcc0636d54">USB_confDmaTx()</a>, and <a class="el" href="group__CSL__USB__FUNCTION.html#ga20e4e8227fc3b0678345d88b40ff4bf0">USB_dmaRxStop()</a>.</p>

</div>
</div>
</div>
<hr class="footer"/><address class="footer"><small>Generated on Thu Jun 23 2011 15:25:55 for C55XX CSL Version 2.50 by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.4 </small></address>
</body>
</html>
